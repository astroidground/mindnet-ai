<!DOCTYPE html>
<!--
üöÄ PURE P2P GENESIS AI - 100% Decentralized Neural Network

HOW IT WORKS:
1. No Firebase! No central server!
2. Peer discovery via:
   - URL sharing (?peer=xxx)
   - localStorage (remembers past peers)
   - Gossip protocol (peers share peer lists)

USAGE:
1. Open this page ‚Üí Get your Peer ID
2. Click "COPY INVITE LINK" 
3. Share link with friends
4. Auto-connect and sync AI models!

NETWORK GROWTH:
- You connect to peer A
- Peer A shares peers B, C, D
- You connect to B, C, D
- Network expands organically!
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pure P2P Genesis AI - Decentralized Neural Network</title>
    
    <!-- CDNs -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/elliptic/6.5.4/elliptic.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

    <!-- No Firebase needed! Pure P2P using localStorage + URL sharing -->

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;600&display=swap');
        
        body {
            font-family: 'Fira Code', monospace;
            background: linear-gradient(135deg, #0A0A0A 0%, #1a0a2e 100%);
            color: #E5E5E5;
        }
        
        .neon-text {
            color: #00FF00;
            text-shadow: 0 0 10px #00FF00, 0 0 20px #00FF00;
        }
        
        .neon-border {
            border: 2px solid #00FF00;
            box-shadow: 0 0 10px #00FF00, inset 0 0 10px rgba(0,255,0,0.1);
        }
        
        .peer-node {
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .terminal-scroll {
            scrollbar-width: thin;
            scrollbar-color: #00FF00 #0A0A0A;
        }
        
        .terminal-scroll::-webkit-scrollbar {
            width: 6px;
        }
        .terminal-scroll::-webkit-scrollbar-track {
            background: #0A0A0A;
        }
        .terminal-scroll::-webkit-scrollbar-thumb {
            background-color: #00FF00;
            border-radius: 3px;
        }
    </style>
</head>
<body class="p-4 min-h-screen">

    <!-- Header -->
    <header class="flex justify-between items-center mb-6 p-4 neon-border bg-black bg-opacity-50">
        <div>
            <h1 class="text-3xl font-bold neon-text">‚ö° PURE P2P GENESIS AI</h1>
            <p class="text-xs text-gray-400">Zero-Server Distributed Neural Network</p>
        </div>
        <div class="text-right">
            <p class="text-xs text-gray-400">WALLET</p>
            <p id="wallet-address" class="text-sm font-bold text-white">Generating...</p>
            <p class="text-xs text-gray-500 mt-1">Balance: <span id="balance" class="text-green-400">0</span> GEN</p>
        </div>
    </header>

    <!-- Main Grid -->
    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
        
        <!-- Left: P2P Network Status -->
        <div class="md:col-span-1 space-y-4">
            
            <!-- Connection Status -->
            <div class="neon-border p-4 bg-black bg-opacity-50">
                <h2 class="text-lg neon-text mb-3">üåê P2P NETWORK</h2>
                
                <!-- Share Button -->
                <button id="share-btn" class="w-full mb-3 py-2 bg-blue-900 hover:bg-blue-700 text-white text-sm font-bold border border-blue-500 transition-colors" disabled>
                    üìã COPY INVITE LINK
                </button>
                
                <div class="space-y-2 text-sm">
                    <div class="flex justify-between">
                        <span class="text-gray-400">My Peer ID</span>
                        <span id="my-peer-id" class="font-mono text-xs">-</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">Connected Peers</span>
                        <span id="connected-peers" class="font-bold text-green-400">0</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">Network Nodes</span>
                        <span id="total-nodes" class="font-bold">0</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">Global Best Loss</span>
                        <span id="global-loss" class="font-bold text-yellow-400">-</span>
                    </div>
            </div>
            
                <div class="mt-4 pt-4 border-t border-gray-700">
                    <p class="text-xs text-gray-400 mb-2">Connected Peers:</p>
                    <div id="peer-list" class="space-y-1 max-h-32 overflow-y-auto terminal-scroll">
                        <p class="text-xs text-gray-500">No peers connected</p>
                </div>
            </div>
        </div>

            <!-- Mining Control -->
            <div class="neon-border p-4 bg-black bg-opacity-50 text-center">
                <h2 class="text-xl font-bold mb-4">‚öôÔ∏è MINING CONTROL</h2>
                <button id="mine-btn" class="w-full py-4 bg-transparent border-2 border-green-500 text-green-500 font-bold text-xl hover:bg-green-500 hover:text-black transition-all duration-200 shadow-[0_0_15px_#00FF00]">
                    START DISTRIBUTED LEARNING
                </button>
                <p id="status-text" class="mt-3 text-sm">
                    Status: <span class="text-red-500">OFFLINE</span>
                </p>
            </div>

            <!-- Stats -->
            <div class="neon-border p-4 bg-black bg-opacity-50">
                <h2 class="text-lg neon-text mb-3">üìä LOCAL STATS</h2>
                <div class="space-y-2 text-sm">
                    <div class="flex justify-between">
                        <span class="text-gray-400">Local Epochs</span>
                        <span id="epochs" class="font-bold">0</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">Best Local Loss</span>
                        <span id="local-loss" class="font-bold text-blue-400">-</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">Model Params</span>
                        <span id="model-params" class="font-bold">-</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">‚õìÔ∏è Blockchain Height</span>
                        <span id="blocks-received" class="font-bold text-purple-400">0</span>
                    </div>
                    </div>
                </div>
            </div>

        <!-- Middle: Training Visualization -->
        <div class="md:col-span-2 space-y-4">
            
            <!-- Loss Chart -->
            <div class="neon-border p-4 bg-black bg-opacity-50 h-80">
                <h2 class="text-lg neon-text mb-2">üß† NEURAL EVOLUTION (LOSS)</h2>
                <canvas id="lossChart"></canvas>
                    </div>
            
            <!-- Current Learning Data -->
            <div class="neon-border p-4 bg-black bg-opacity-50">
                <h2 class="text-lg neon-text mb-2">üìñ CURRENTLY LEARNING</h2>
                <div id="learning-preview" class="text-xs p-3 bg-gray-900 bg-opacity-50 text-gray-300 italic rounded h-24 overflow-y-auto terminal-scroll">
                    <span class="text-gray-500">No data yet...</span>
                    </div>
                    </div>
            
            <!-- P2P Activity Feed -->
            <div class="neon-border p-4 bg-black bg-opacity-50 flex flex-col">
                <h2 class="text-lg neon-text mb-2">üì° P2P ACTIVITY LOG</h2>
                <div id="activity-feed" class="terminal-scroll flex-grow overflow-y-auto h-48 text-xs space-y-1 p-2 bg-gray-900 bg-opacity-30 font-mono">
                    <p class="text-gray-500">> System initialized in Pure P2P mode</p>
                    <p class="text-gray-500">> No central server - all data P2P synchronized</p>
                    </div>
                </div>
            
            <!-- AI Inference Test -->
            <div class="neon-border p-4 bg-black bg-opacity-50">
                <h2 class="text-lg neon-text mb-2">ü§ñ TEST LOCAL AI</h2>
                <div class="flex gap-2">
                    <input type="text" id="inference-input" placeholder="Type seed text..." class="flex-grow bg-black border border-green-900 text-green-400 p-2 text-sm">
                    <button id="inference-btn" class="px-4 py-2 bg-green-900 hover:bg-green-700 text-white font-bold">GENERATE</button>
            </div>
                <div id="inference-output" class="mt-2 p-2 bg-gray-900 text-green-300 text-sm min-h-12 hidden"></div>
        </div>
        </div>
    </div>

    <script>
        // ============================================
        // PURE P2P GENESIS AI - ZERO SERVER ARCHITECTURE
        // ============================================
        
        console.log("üöÄ Initializing Pure P2P Genesis AI...");
        
        // --- Configuration ---
        const SEQUENCE_LENGTH = 10;
        const VOCAB = 'abcdefghijklmnopqrstuvwxyz .';
        const vocab = VOCAB.split('');
        const charToIndex = {};
        const indexToChar = {};
        vocab.forEach((c, i) => {
            charToIndex[c] = i;
            indexToChar[i] = c;
        });
        
        const MAX_PEERS = 5; // Connect to maximum 5 peers
        const GOSSIP_INTERVAL = 5000; // Broadcast state every 5 seconds
        const TRAINING_DATA_LENGTH = 200; // Length of training text
        
        // --- Wallet & Security ---
        const EC = elliptic.ec;
        const ec = new EC('secp256k1');
        
        let keyPair, privateKey, publicKey, walletAddress;
        
        function initWallet() {
            const saved = localStorage.getItem('p2p_genesis_wallet');
            if (saved) {
                privateKey = saved;
                keyPair = ec.keyFromPrivate(privateKey);
                console.log("üîê Wallet restored from localStorage");
            } else {
                keyPair = ec.genKeyPair();
                privateKey = keyPair.getPrivate('hex');
                localStorage.setItem('p2p_genesis_wallet', privateKey);
                console.log("üÜï New wallet generated");
            }
            publicKey = keyPair.getPublic('hex');
            walletAddress = "P2P_" + publicKey.substring(0, 12).toUpperCase();
            document.getElementById('wallet-address').innerText = walletAddress;
        }
        
        initWallet();
        
        // --- P2P Network State ---
        let peer = null;
        let myPeerId = null;
        let connections = {}; // {peerId: connection}
        let networkState = {
            bestLoss: 9.9,
            bestWeights: null,
            blocksReceived: 0
        };
        
        // ============================================
        // BLOCKCHAIN IMPLEMENTATION
        // ============================================
        
        class Block {
            constructor(index, timestamp, previousHash, data) {
                this.index = index;
                this.timestamp = timestamp;
                this.previousHash = previousHash;
                this.miner = data.miner;
                this.loss = data.loss;
                this.weightsHash = data.weightsHash;
                this.peerId = data.peerId;
                this.hash = this.calculateHash();
            }
            
            calculateHash() {
                const data = this.index + this.timestamp + this.previousHash + 
                            this.miner + this.loss + this.weightsHash;
                // Simple hash (in production, use SHA-256)
                let hash = 0;
                for (let i = 0; i < data.length; i++) {
                    const char = data.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash;
                }
                return Math.abs(hash).toString(16).padStart(16, '0');
            }
        }
        
        class Blockchain {
            constructor() {
                this.chain = this.loadChain() || [this.createGenesisBlock()];
                this.saveChain();
            }
            
            createGenesisBlock() {
                return new Block(0, Date.now(), "0", {
                    miner: "GENESIS",
                    loss: 9.9,
                    weightsHash: "0000000000000000",
                    peerId: "SYSTEM"
                });
            }
            
            getLatestBlock() {
                return this.chain[this.chain.length - 1];
            }
            
            addBlock(data) {
                const previousBlock = this.getLatestBlock();
                const newBlock = new Block(
                    previousBlock.index + 1,
                    Date.now(),
                    previousBlock.hash,
                    data
                );
                
                // Validate before adding
                if (this.isValidNewBlock(newBlock, previousBlock)) {
                    this.chain.push(newBlock);
                    this.saveChain();
                    
                    // Broadcast to network
                    this.broadcastBlock(newBlock);
                    
                    console.log(`‚õìÔ∏è Block #${newBlock.index} added to chain`);
                    return newBlock;
                }
                return null;
            }
            
            isValidNewBlock(newBlock, previousBlock) {
                if (previousBlock.index + 1 !== newBlock.index) {
                    console.warn("Invalid index");
                    return false;
                }
                if (previousBlock.hash !== newBlock.previousHash) {
                    console.warn("Invalid previous hash");
                    return false;
                }
                if (newBlock.calculateHash() !== newBlock.hash) {
                    console.warn("Invalid hash");
                    return false;
                }
                return true;
            }
            
            isValidChain(chain) {
                if (JSON.stringify(chain[0]) !== JSON.stringify(this.createGenesisBlock())) {
                    return false;
                }
                
                for (let i = 1; i < chain.length; i++) {
                    const block = Object.assign(new Block(0, 0, "0", {}), chain[i]);
                    const previousBlock = chain[i - 1];
                    
                    if (!this.isValidNewBlock(block, previousBlock)) {
                        return false;
                    }
                }
                return true;
            }
            
            replaceChain(newChain) {
                if (newChain.length > this.chain.length && this.isValidChain(newChain)) {
                    console.log('üîÑ Replacing chain with longer valid chain');
                    this.chain = newChain;
                    this.saveChain();
                    return true;
                }
                return false;
            }
            
            saveChain() {
                try {
                    localStorage.setItem('p2p_blockchain', JSON.stringify(this.chain));
                } catch(e) {
                    console.error("Failed to save blockchain:", e);
                }
            }
            
            loadChain() {
                try {
                    const saved = localStorage.getItem('p2p_blockchain');
                    if (saved) {
                        const chain = JSON.parse(saved);
                        console.log(`üìÇ Loaded blockchain: ${chain.length} blocks`);
                        return chain;
                    }
                } catch(e) {
                    console.error("Failed to load blockchain:", e);
                }
                return null;
            }
            
            broadcastBlock(block) {
                Object.values(connections).forEach(conn => {
                    try {
                        conn.send({
                            type: 'new_block',
                            block: block
                        });
                    } catch(e) {
                        console.error("Failed to broadcast block:", e);
                    }
                });
            }
            
            getBlockchainHeight() {
                return this.chain.length - 1; // Exclude genesis
            }
        }
        
        // Initialize blockchain
        let blockchain = new Blockchain();
        
        // Update UI
        document.getElementById('blocks-received').innerText = blockchain.getBlockchainHeight();
        
        // --- AI Model ---
        let model = null;
        let isMining = false;
        let epochCount = 0;
        let localBestLoss = 9.9;
        let lossHistory = [];
        
        // --- Chart ---
        let lossChart = null;
        
        // ============================================
        // PEER DISCOVERY (No Firebase!)
        // ============================================
        
        // Method 1: URL parameter (share link to connect)
        // Method 2: localStorage (remember previous peers)
        // Method 3: Bootstrap node (hardcoded seed peer)
        
        let knownPeers = new Set();
        
        // Load previously connected peers from localStorage
        function loadKnownPeers() {
            try {
                const saved = localStorage.getItem('p2p_known_peers');
                if (saved) {
                    const peers = JSON.parse(saved);
                    peers.forEach(p => knownPeers.add(p));
                    console.log(`üìÇ Loaded ${peers.length} known peers from history`);
                }
            } catch(e) {
                console.error("Failed to load known peers:", e);
            }
        }
        
        // Save peer for future connections
        function rememberPeer(peerId) {
            knownPeers.add(peerId);
            try {
                localStorage.setItem('p2p_known_peers', JSON.stringify([...knownPeers]));
            } catch(e) {
                console.error("Failed to save peer:", e);
            }
        }
        
        // Get peer ID from URL parameter (?peer=xxx)
        function getPeerFromURL() {
            const params = new URLSearchParams(window.location.search);
            return params.get('peer');
        }
        
        // Generate shareable URL with your peer ID
        function generateShareURL() {
            if (!myPeerId) return '';
            const baseURL = window.location.origin + window.location.pathname;
            return `${baseURL}?peer=${myPeerId}`;
        }
        
        loadKnownPeers();
        
        // ============================================
        // PEERJS INITIALIZATION
        // ============================================
        
        function initP2P() {
            peer = new Peer({
                config: {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:global.stun.twilio.com:3478' }
                    ]
                }
            });
            
            peer.on('open', (id) => {
                myPeerId = id;
                document.getElementById('my-peer-id').innerText = id.substring(0, 8) + "...";
                console.log("üÜî My Peer ID:", id);
                addLog(`üÜî Peer ID: ${id.substring(0, 12)}...`, "success");
                
                // Enable share button
                document.getElementById('share-btn').disabled = false;
                
                // Show shareable URL
                const shareURL = generateShareURL();
                addLog(`üìã Share URL: ${shareURL.substring(0, 50)}...`, "info");
                
                // Check URL for peer to connect to
                const urlPeer = getPeerFromURL();
                if (urlPeer && urlPeer !== id) {
                    addLog(`üîó Found peer in URL: ${urlPeer.substring(0, 12)}...`, "info");
                    connectToPeer(urlPeer);
                }
                
                // Reconnect to known peers
                if (knownPeers.size > 0) {
                    addLog(`üîÑ Reconnecting to ${knownPeers.size} known peers...`, "info");
                    knownPeers.forEach(peerId => {
                        if (peerId !== id) {
                            setTimeout(() => connectToPeer(peerId), 1000);
                        }
                    });
                }
                
                // Update total nodes (self + known peers)
                document.getElementById('total-nodes').innerText = knownPeers.size + 1;
            });
            
            peer.on('connection', (conn) => {
                setupConnection(conn);
                addLog(`üì• Incoming connection from ${conn.peer.substring(0, 8)}...`, "info");
            });
            
            peer.on('error', (err) => {
                console.error("PeerJS Error:", err);
                addLog(`‚ùå P2P Error: ${err.type}`, "error");
            });
        }
        
        // ============================================
        // PEER CONNECTION
        // ============================================
        
        function connectToPeer(peerId) {
            if (connections[peerId]) return;
            
            const conn = peer.connect(peerId, { reliable: true });
            setupConnection(conn);
        }
        
        function setupConnection(conn) {
            connections[conn.peer] = conn;
            
            conn.on('open', () => {
                addLog(`‚úÖ Connected to ${conn.peer.substring(0, 8)}...`, "success");
                
                // Remember this peer for future connections
                rememberPeer(conn.peer);
                
                updatePeerList();
                
                // Send my current state
                sendToPeer(conn, {
                    type: 'hello',
                    loss: localBestLoss,
                    wallet: walletAddress,
                    myPeerId: myPeerId
                });
                
                // Request weights if I'm a new node (high loss = untrained)
                if (localBestLoss > 5.0 && model) {
                    addLog(`üì• Requesting trained model from ${conn.peer.substring(0, 8)}...`, "info");
                    sendToPeer(conn, {
                        type: 'request_weights'
                    });
                }
                
                // Request blockchain if peer might have longer chain
                setTimeout(() => {
                    sendToPeer(conn, {
                        type: 'request_chain'
                    });
                }, 1000);
            });
            
            conn.on('data', (data) => {
                handlePeerMessage(conn.peer, data);
            });
            
            conn.on('close', () => {
                delete connections[conn.peer];
                addLog(`‚ùå Disconnected from ${conn.peer.substring(0, 8)}...`, "warn");
                updatePeerList();
            });
        }
        
        function updatePeerList() {
            const connectedCount = Object.keys(connections).length;
            document.getElementById('connected-peers').innerText = connectedCount;
            
            const peerListEl = document.getElementById('peer-list');
            if (connectedCount === 0) {
                peerListEl.innerHTML = '<p class="text-xs text-gray-500">No peers connected</p>';
            } else {
                peerListEl.innerHTML = Object.keys(connections).map(peerId => 
                    `<div class="flex items-center gap-2 text-xs">
                        <div class="w-2 h-2 rounded-full bg-green-500 peer-node"></div>
                        <span class="font-mono">${peerId.substring(0, 12)}...</span>
                    </div>`
                ).join('');
            }
        }
        
        // ============================================
        // GOSSIP PROTOCOL & CONSENSUS
        // ============================================
        
        function broadcastToNetwork(message) {
            Object.values(connections).forEach(conn => {
                try {
                    conn.send(message);
                } catch(e) {
                    console.error("Failed to send to peer:", e);
                }
            });
        }
        
        function sendToPeer(conn, message) {
            try {
                conn.send(message);
            } catch(e) {
                console.error("Failed to send message:", e);
            }
        }
        
        function handlePeerMessage(peerId, data) {
            console.log("üì® Received from", peerId.substring(0, 8), ":", data.type);
            
            switch(data.type) {
                case 'hello':
                    addLog(`üëã ${peerId.substring(0, 8)}... says hello (Loss: ${data.loss?.toFixed(4)})`, "info");
                    
                    // Gossip: Share my known peers with new peer
                    if (data.myPeerId && knownPeers.size > 1) {
                        const peersToShare = [...knownPeers].filter(p => p !== peerId && p !== data.myPeerId).slice(0, 3);
                        if (peersToShare.length > 0) {
                            sendToPeer(connections[peerId], {
                                type: 'peer_list',
                                peers: peersToShare
                            });
                        }
                    }
                    break;
                    
                case 'peer_list':
                    // Discovered new peers through gossip
                    if (data.peers && Array.isArray(data.peers)) {
                        data.peers.forEach(newPeer => {
                            if (newPeer !== myPeerId && !connections[newPeer] && Object.keys(connections).length < MAX_PEERS) {
                                addLog(`üîç Discovered peer through gossip: ${newPeer.substring(0, 8)}...`, "info");
                                setTimeout(() => connectToPeer(newPeer), Math.random() * 2000);
                            }
                        });
                    }
                    break;
                    
                case 'weights_update':
                    handleWeightsUpdate(peerId, data);
                    break;
                    
                case 'block':
                    handleNewBlock(peerId, data);
                    break;
                    
                case 'request_weights':
                    sendMyWeights(peerId);
                    break;
                    
                case 'new_block':
                    handleNewBlock(peerId, data);
                    break;
                    
                case 'request_chain':
                    // Send full blockchain to peer
                    sendToPeer(connections[peerId], {
                        type: 'blockchain',
                        chain: blockchain.chain
                    });
                    break;
                    
                case 'blockchain':
                    // Received full chain from peer
                    if (data.chain && blockchain.replaceChain(data.chain)) {
                        addLog(`üîÑ Updated blockchain from ${peerId.substring(0, 8)}... (${data.chain.length} blocks)`, "success");
                        document.getElementById('blocks-received').innerText = blockchain.getBlockchainHeight();
                    }
                    break;
            }
        }
        
        function handleNewBlock(peerId, data) {
            const block = Object.assign(new Block(0, 0, "0", {}), data.block);
            const latestBlock = blockchain.getLatestBlock();
            
            if (block.index === latestBlock.index + 1) {
                // Next block in sequence
                if (blockchain.isValidNewBlock(block, latestBlock)) {
                    blockchain.chain.push(block);
                    blockchain.saveChain();
                    document.getElementById('blocks-received').innerText = blockchain.getBlockchainHeight();
                    
                    addLog(`‚õìÔ∏è Block #${block.index} received from ${peerId.substring(0, 8)}...`, "success");
                    
                    // Relay to other peers (gossip)
                    Object.keys(connections).forEach(pid => {
                        if (pid !== peerId) {
                            sendToPeer(connections[pid], {
                                type: 'new_block',
                                block: block
                            });
                        }
                    });
                }
            } else if (block.index > latestBlock.index + 1) {
                // Missing blocks, request full chain
                addLog(`‚ö†Ô∏è Missing blocks detected, requesting full chain...`, "warn");
                sendToPeer(connections[peerId], {
                    type: 'request_chain'
                });
            }
        }
        
        async function handleWeightsUpdate(peerId, data) {
            const receivedLoss = data.loss;
            const receivedWeights = data.weights;
            
            addLog(`üß† Weights received from ${peerId.substring(0, 8)}... (Loss: ${receivedLoss.toFixed(4)})`, "info");
            
            // Consensus: Only accept if better than local
            if (receivedLoss < localBestLoss && receivedWeights) {
                console.log(`‚úÖ Accepting better weights (${receivedLoss.toFixed(4)} < ${localBestLoss.toFixed(4)})`);
                
                try {
                    // Apply weights to model
                    if (model) {
                        const tensors = receivedWeights.map(w => tf.tensor(w.data, w.shape));
                        model.setWeights(tensors);
                        tensors.forEach(t => t.dispose());
                        
                        localBestLoss = receivedLoss;
                        document.getElementById('local-loss').innerText = localBestLoss.toFixed(4);
                        
                        // Save to localStorage
                        saveWeightsToStorage(receivedWeights, receivedLoss);
                        
                        addLog(`‚úÖ Applied better weights from network`, "success");
                        
                        // Gossip to other peers
                        broadcastToNetwork({
                            type: 'weights_update',
                            loss: receivedLoss,
                            weights: receivedWeights,
                            origin: peerId
                        });
                    }
                } catch(e) {
                    console.error("Failed to apply weights:", e);
                }
            } else {
                console.log(`‚ùå Rejecting weights (${receivedLoss.toFixed(4)} >= ${localBestLoss.toFixed(4)})`);
            }
            
            // Update global best
            if (receivedLoss < networkState.bestLoss) {
                networkState.bestLoss = receivedLoss;
                document.getElementById('global-loss').innerText = receivedLoss.toFixed(4);
            }
        }
        
        function handleNewBlock(peerId, data) {
            networkState.blocksReceived++;
            document.getElementById('blocks-received').innerText = networkState.blocksReceived;
            addLog(`‚õìÔ∏è Block #${data.blockNumber} from ${peerId.substring(0, 8)}...`, "info");
        }
        
        function sendMyWeights(peerId) {
            if (!model) return;
            
            addLog(`üì§ Sharing my model (Loss: ${localBestLoss.toFixed(4)}) with ${peerId.substring(0, 8)}...`, "info");
            
            const weights = model.getWeights().map(w => ({
                data: Array.from(w.dataSync()),
                shape: w.shape
            }));
            
            const conn = connections[peerId];
            if (conn) {
                sendToPeer(conn, {
                    type: 'weights_update',
                    loss: localBestLoss,
                    weights: weights
                });
            }
        }
        
        // ============================================
        // TENSORFLOW.JS MODEL
        // ============================================
        
        async function createModel() {
            const model = tf.sequential();
            
            model.add(tf.layers.embedding({
                inputDim: vocab.length,
                outputDim: 32,
                inputLength: SEQUENCE_LENGTH
            }));
            
            model.add(tf.layers.lstm({
                units: 32,
                returnSequences: false
            }));
            
            model.add(tf.layers.dense({
                units: vocab.length,
                activation: 'softmax'
            }));
            
            model.compile({
                optimizer: 'adam',
                loss: 'categoricalCrossentropy'
            });
            
            const params = model.countParams();
            document.getElementById('model-params').innerText = (params / 1000).toFixed(1) + 'K';
            
            console.log("üß† Model created:", params, "parameters");
            return model;
        }

        // --- Wikipedia Data Foraging (Same as Python server!) ---
        const WIKI_TOPICS = [
            "Artificial_intelligence", 
            "Evolution", 
            "Blockchain", 
            "Neural_network", 
            "Machine_learning",
            "Genetic_algorithm", 
            "Life", 
            "Universe", 
            "Philosophy", 
            "Mathematics",
            "Computer_science",
            "Quantum_computing",
            "Cryptography",
            "Information_theory"
        ];
        
        let cachedWikiText = null;
        let lastFetchTime = 0;
        const FETCH_INTERVAL = 30000; // Fetch new data every 30 seconds
        
        async function fetchWikipediaData() {
            try {
                const topic = WIKI_TOPICS[Math.floor(Math.random() * WIKI_TOPICS.length)];
                const url = `https://en.wikipedia.org/api/rest_v1/page/summary/${topic}`;
                
                const response = await fetch(url);
                if (!response.ok) throw new Error("Wikipedia fetch failed");
                
                const data = await response.json();
                const text = data.extract || data.description || "";
                
                if (text.length > 100) {
                    // Show what we're learning
                    const preview = text.substring(0, 200) + "...";
                    const topicName = topic.replace(/_/g, ' ');
                    document.getElementById('learning-preview').innerHTML = 
                        `<div class="text-yellow-400 font-bold mb-1">üìö ${topicName}</div>` +
                        `<div class="text-gray-300">${preview}</div>`;
                    
                    addLog(`üìö Learning: ${topicName}`, "info");
                    return text;
                }
            } catch (e) {
                console.warn("Wikipedia fetch error:", e);
            }
            
            // Fallback
            const fallback = "Artificial intelligence and machine learning are transforming our world through neural networks and distributed computing systems.";
            document.getElementById('learning-preview').innerHTML = 
                `<div class="text-gray-500">Fallback training data</div>`;
            return fallback;
        }
        
        async function generateTrainingData() {
            const now = Date.now();
            
            // Fetch new data if cache is old or empty
            if (!cachedWikiText || (now - lastFetchTime > FETCH_INTERVAL)) {
                cachedWikiText = await fetchWikipediaData();
                lastFetchTime = now;
            }
            
            return cachedWikiText;
        }
        
        function processData(text) {
            const xs = [];
            const ys = [];
            
            text = text.toLowerCase().replace(/[^a-z .]/g, '');
            
            if (text.length <= SEQUENCE_LENGTH) return { xs: null, ys: null };
            
            for (let i = 0; i < text.length - SEQUENCE_LENGTH; i++) {
                const seq = text.slice(i, i + SEQUENCE_LENGTH);
                const target = text[i + SEQUENCE_LENGTH];
                
                xs.push(seq.split('').map(c => charToIndex[c] || 0));
                
                const y = new Array(vocab.length).fill(0);
                y[charToIndex[target] || 0] = 1;
                ys.push(y);
            }
            
            if (xs.length === 0) return { xs: null, ys: null };
            
            return {
                xs: tf.tensor2d(xs, [xs.length, SEQUENCE_LENGTH]),
                ys: tf.tensor2d(ys, [ys.length, vocab.length])
            };
        }

        async function trainStep() {
            if (!isMining || !model) return;
            
            try {
                const trainingText = await generateTrainingData();
                const { xs, ys } = processData(trainingText);
                
                if (!xs || !ys) {
                    setTimeout(trainStep, 1000);
                    return;
                }
                
            const history = await model.fit(xs, ys, {
                epochs: 1,
                    batchSize: 32,
                    shuffle: true,
                    verbose: 0
            });
            
            const loss = history.history.loss[0];
            
                xs.dispose();
                ys.dispose();
                
                epochCount++;
                document.getElementById('epochs').innerText = epochCount;
                
                // Update chart (keep only last 10 data points)
                lossHistory.push(loss);
                if (lossHistory.length > 10) lossHistory.shift();
                updateChart();
                
                // If we found a better model, broadcast it
                if (loss < localBestLoss) {
                    localBestLoss = loss;
                    document.getElementById('local-loss').innerText = loss.toFixed(4);
                    
                    addLog(`üéâ New best local loss: ${loss.toFixed(4)}`, "success");
                    
                    // Extract and broadcast weights
                    const weights = model.getWeights().map(w => ({
                        data: Array.from(w.dataSync()),
                        shape: w.shape
                    }));
                    
                    // Calculate weights hash
                    const weightsHash = weights.map(w => w.data.reduce((a, b) => a + b, 0))
                        .reduce((a, b) => a + b, 0)
                        .toString(16)
                        .substring(0, 16);
                    
                    // Add block to blockchain
                    const newBlock = blockchain.addBlock({
                        miner: walletAddress,
                        loss: loss,
                        weightsHash: weightsHash,
                        peerId: myPeerId
                    });
                    
                    if (newBlock) {
                        document.getElementById('blocks-received').innerText = blockchain.getBlockchainHeight();
                        addLog(`‚õìÔ∏è Block #${newBlock.index} mined!`, "success");
                    }
                    
                    broadcastToNetwork({
                        type: 'weights_update',
                        loss: loss,
                        weights: weights,
                        origin: myPeerId
                    });
                    
                    // Save to localStorage
                    saveWeightsToStorage(weights, loss);
                    
                    // Update global best
                    if (loss < networkState.bestLoss) {
                        networkState.bestLoss = loss;
                        document.getElementById('global-loss').innerText = loss.toFixed(4);
                    }
                }
                
                setTimeout(trainStep, 0);
                
            } catch(e) {
                console.error("Training error:", e);
                addLog(`‚ùå Training error: ${e.message}`, "error");
                await new Promise(r => setTimeout(r, 1000));
                if (isMining) setTimeout(trainStep, 0);
            }
        }
        
        // ============================================
        // LOCAL STORAGE PERSISTENCE
        // ============================================
        
        function saveWeightsToStorage(weights, loss) {
            try {
                localStorage.setItem('p2p_best_weights', JSON.stringify({
                    weights: weights,
                    loss: loss,
                    timestamp: Date.now()
                }));
                console.log("üíæ Weights saved to localStorage");
            } catch(e) {
                console.error("Failed to save weights:", e);
            }
        }
        
        function loadWeightsFromStorage() {
            try {
                const saved = localStorage.getItem('p2p_best_weights');
                if (saved) {
                    const data = JSON.parse(saved);
                    console.log("üìÇ Found saved weights (Loss:", data.loss.toFixed(4), ")");
                    return data;
                }
            } catch(e) {
                console.error("Failed to load weights:", e);
            }
            return null;
        }
        
        // ============================================
        // UI & VISUALIZATION
        // ============================================
        
        function addLog(message, type = "info") {
            const feed = document.getElementById('activity-feed');
            const p = document.createElement('p');
            
            const colors = {
                info: 'text-blue-400',
                success: 'text-green-400',
                warn: 'text-yellow-400',
                error: 'text-red-400'
            };
            
            p.className = colors[type] || 'text-gray-400';
            p.innerHTML = `<span class="text-gray-600">[${new Date().toLocaleTimeString()}]</span> ${message}`;
            feed.prepend(p);
            
            // Keep only last 20 logs
            while(feed.children.length > 20) {
                feed.lastChild.remove();
            }
        }
        
        function initChart() {
            const ctx = document.getElementById('lossChart').getContext('2d');
            lossChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Local Loss',
                        data: [],
                        borderColor: '#00FF00',
                        backgroundColor: 'rgba(0, 255, 0, 0.1)',
                        tension: 0.4,
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: { 
                            beginAtZero: false,
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            ticks: { color: '#00FF00' }
                        },
                        x: { 
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            ticks: { color: '#00FF00' }
                        }
                    },
                    plugins: {
                        legend: { labels: { color: '#00FF00' } }
                    }
                }
            });
        }
        
        function updateChart() {
            if (!lossChart) return;
            
            lossChart.data.labels = lossHistory.map((_, i) => i);
            lossChart.data.datasets[0].data = lossHistory;
            lossChart.update('none');
        }
        
        // ============================================
        // AI INFERENCE
        // ============================================
        
        async function generateText(seed, length = 50) {
            if (!model) throw new Error("Model not ready");
            
            seed = seed.toLowerCase().replace(/[^a-z .]/g, '');
            if (seed.length < 5) seed = "genesis ai";
            
            let inputIndices = seed.split('').map(c => charToIndex[c] || 0);
            let generated = "";
            
            for (let i = 0; i < length; i++) {
                const char = tf.tidy(() => {
                    const seq = inputIndices.slice(-SEQUENCE_LENGTH);
                    while (seq.length < SEQUENCE_LENGTH) seq.unshift(0);
                    
                    const inputTensor = tf.tensor2d([seq]);
                    const prediction = model.predict(inputTensor);
                    const logits = prediction.dataSync();
                    
                    const maxIdx = logits.indexOf(Math.max(...logits));
                    return indexToChar[maxIdx];
                });
                
                generated += char;
                inputIndices.push(charToIndex[char] || 0);
            }
            
            return generated;
        }
        
        // ============================================
        // EVENT LISTENERS
        // ============================================
        
        document.getElementById('mine-btn').addEventListener('click', async () => {
            const btn = document.getElementById('mine-btn');
            const status = document.getElementById('status-text');
            
            if (!isMining) {
                // Start mining
                if (!model) {
                    model = await createModel();
                    
                    // Load saved weights if available
                    const saved = loadWeightsFromStorage();
                    if (saved) {
                        try {
                            const tensors = saved.weights.map(w => tf.tensor(w.data, w.shape));
                            model.setWeights(tensors);
                            tensors.forEach(t => t.dispose());
                            localBestLoss = saved.loss;
                            document.getElementById('local-loss').innerText = localBestLoss.toFixed(4);
                            addLog(`üìÇ Loaded saved weights (Loss: ${localBestLoss.toFixed(4)})`, "success");
                        } catch(e) {
                            console.error("Failed to load saved weights:", e);
                        }
                    }
                }
                
                isMining = true;
                btn.innerText = "STOP LEARNING";
                btn.classList.add('bg-green-500', 'text-black');
                status.innerHTML = 'Status: <span class="text-green-500">MINING ‚ö°</span>';
                
                addLog("‚ö° Started distributed learning", "success");
                trainStep();
            } else {
                // Stop mining
                isMining = false;
                btn.innerText = "START DISTRIBUTED LEARNING";
                btn.classList.remove('bg-green-500', 'text-black');
                status.innerHTML = 'Status: <span class="text-red-500">OFFLINE</span>';
                
                addLog("‚è∏Ô∏è Stopped learning", "warn");
            }
        });
        
        document.getElementById('share-btn').addEventListener('click', async () => {
            const shareURL = generateShareURL();
            
            try {
                await navigator.clipboard.writeText(shareURL);
                addLog("üìã Invite link copied to clipboard!", "success");
                
                const btn = document.getElementById('share-btn');
                const originalText = btn.innerText;
                btn.innerText = "‚úÖ COPIED!";
                setTimeout(() => {
                    btn.innerText = originalText;
                }, 2000);
            } catch(e) {
                // Fallback: show URL in prompt
                prompt("Copy this URL to invite peers:", shareURL);
            }
        });
        
        document.getElementById('inference-btn').addEventListener('click', async () => {
            const input = document.getElementById('inference-input');
            const output = document.getElementById('inference-output');
            const seed = input.value.trim();
            
            if (!seed) return;
            
            try {
                output.classList.remove('hidden');
                output.innerHTML = '<span class="animate-pulse">Generating...</span>';
                
                const text = await generateText(seed, 80);
                output.innerHTML = `<span class="text-gray-400">Seed:</span> "${seed}"<br><span class="text-green-400">Generated:</span> ${text}`;
                
                addLog(`ü§ñ Generated text from seed: "${seed.substring(0, 20)}..."`, "info");
            } catch(e) {
                output.innerHTML = `<span class="text-red-400">Error: ${e.message}</span>`;
            }
        });
        
        // ============================================
        // INITIALIZATION
        // ============================================
        
        initChart();
        initP2P();
        
        // Periodic gossip
        setInterval(() => {
            if (Object.keys(connections).length > 0) {
                broadcastToNetwork({
                    type: 'hello',
                    loss: localBestLoss,
                    wallet: walletAddress,
                    myPeerId: myPeerId
                });
            }
        }, GOSSIP_INTERVAL);
        
        addLog("üöÄ Pure P2P Genesis AI initialized", "success");
        addLog("‚ö° Zero servers - No Firebase - Fully decentralized!", "info");
        addLog("üí° Click 'COPY INVITE LINK' to share with friends", "info");
        
    </script>
</body>
</html>



