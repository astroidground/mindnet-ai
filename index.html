<!DOCTYPE html>
<!--
üöÄ PURE P2P GENESIS AI - 100% Decentralized Neural Network

HOW IT WORKS:
1. No Firebase! No central server!
2. Peer discovery via:
   - URL sharing (?peer=xxx)
   - localStorage (remembers past peers)
   - Gossip protocol (peers share peer lists)

USAGE:
1. Open this page ‚Üí Get your Peer ID
2. Click "COPY INVITE LINK" 
3. Share link with friends
4. Auto-connect and sync AI models!

NETWORK GROWTH:
- You connect to peer A
- Peer A shares peers B, C, D
- You connect to B, C, D
- Network expands organically!
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pure P2P Genesis AI - Decentralized Neural Network</title>
    
    <!-- CDNs -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/elliptic/6.5.4/elliptic.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/helia@latest/dist/index.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@helia/unixfs@latest/dist/index.min.js"></script>

    <!-- No Firebase, No Central Server! Pure P2P + IPFS Decentralized Storage -->

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;600&display=swap');
        
        body {
            font-family: 'Fira Code', monospace;
            background: linear-gradient(135deg, #0A0A0A 0%, #1a0a2e 100%);
            color: #E5E5E5;
        }
        
        .neon-text {
            color: #00FF00;
            text-shadow: 0 0 10px #00FF00, 0 0 20px #00FF00;
        }
        
        .neon-border {
            border: 2px solid #00FF00;
            box-shadow: 0 0 10px #00FF00, inset 0 0 10px rgba(0,255,0,0.1);
        }
        
        .peer-node {
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .terminal-scroll {
            scrollbar-width: thin;
            scrollbar-color: #00FF00 #0A0A0A;
        }
        
        .terminal-scroll::-webkit-scrollbar {
            width: 6px;
        }
        .terminal-scroll::-webkit-scrollbar-track {
            background: #0A0A0A;
        }
        .terminal-scroll::-webkit-scrollbar-thumb {
            background-color: #00FF00;
            border-radius: 3px;
        }
        
        /* Tab Navigation Styles */
        .tab-btn {
            position: relative;
            transition: all 0.3s ease;
        }
        
        .tab-btn:hover {
            transform: translateY(-2px);
        }
        
        .tab-btn.active {
            font-weight: bold;
        }
        
        .tab-content {
            animation: fadeIn 0.3s ease-in-out;
            min-height: calc(100vh - 200px);
        }
        
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        /* Explorer table styles */
        #blockchain-table tr:hover,
        #ledger-table tr:hover {
            transform: scale(1.01);
            transition: transform 0.2s ease;
        }
    </style>
</head>
<body class="p-0 min-h-screen overflow-x-hidden">

    <!-- Header with Navigation -->
    <header class="sticky top-0 z-50 bg-black border-b-2 border-cyan-500 shadow-[0_0_20px_#00FFFF]">
        <div class="flex justify-between items-center p-4">
            <div>
                <h1 class="text-2xl font-bold neon-text">‚ö° GENESIS AI</h1>
                <p class="text-xs text-gray-400">Decentralized Intelligence Network</p>
        </div>
        <div class="text-right">
                <p class="text-xs text-gray-400">WALLET</p>
                <p id="wallet-address" class="text-xs font-mono text-white">Generating...</p>
                <p class="text-xs text-gray-500">Balance: <span id="balance" class="text-green-400">0</span> GEN</p>
        </div>
        </div>
        
        <!-- Navigation Tabs -->
        <nav class="flex border-t border-gray-800">
            <button class="tab-btn flex-1 px-6 py-4 text-sm font-bold transition-all duration-200 border-b-4 border-transparent hover:bg-gray-900" 
                    data-tab="chat" 
                    style="color: #00FF88;">
                <span class="text-xl">üí¨</span><br>AI CHAT
            </button>
            <button class="tab-btn flex-1 px-6 py-4 text-sm font-bold transition-all duration-200 border-b-4 border-transparent hover:bg-gray-900 active" 
                    data-tab="miner" 
                    style="color: #00FFFF;">
                <span class="text-xl">‚õèÔ∏è</span><br>MINER
            </button>
            <button class="tab-btn flex-1 px-6 py-4 text-sm font-bold transition-all duration-200 border-b-4 border-transparent hover:bg-gray-900" 
                    data-tab="explorer" 
                    style="color: #FFFFFF;">
                <span class="text-xl">üîç</span><br>EXPLORER
            </button>
        </nav>
    </header>

    <!-- Main Container -->
    <div class="container mx-auto">
        
        <!-- ========================================== -->
        <!-- üí¨ AI CHAT TAB (Consumer View) -->
        <!-- ========================================== -->
        <div id="tab-chat" class="tab-content hidden p-6" style="background: linear-gradient(to bottom, #001a00, #000000);">
            
            <div class="max-w-4xl mx-auto space-y-4">
                
                <!-- Chat Interface -->
                <div class="bg-gradient-to-br from-green-900 to-black border-2 border-green-500 rounded-lg p-6 shadow-[0_0_30px_rgba(0,255,136,0.3)]">
                    <h2 class="text-2xl font-bold mb-4 text-green-400">üí¨ Ask Genesis AI</h2>
                    <p class="text-sm text-gray-400 mb-4">Powered by decentralized neural network</p>
                    
                    <div class="flex gap-2 mb-4">
                        <input type="text" id="inference-input" placeholder="What would you like to know?" 
                               class="flex-grow bg-black border-2 border-green-700 text-green-300 p-3 text-sm rounded focus:border-green-400 focus:outline-none placeholder-green-800">
                        <button id="inference-btn" class="px-6 py-3 bg-green-600 hover:bg-green-500 text-white font-bold rounded transition-all shadow-[0_0_15px_rgba(0,255,136,0.5)]">
                            ASK
                        </button>
            </div>
            
                    <div id="inference-output" class="mt-4 p-4 bg-black bg-opacity-70 text-green-300 text-sm min-h-20 rounded border border-green-900 hidden"></div>
                </div>
                
                <!-- Network Info (Simplified) -->
                <div class="grid grid-cols-2 gap-4">
                    <div class="bg-black bg-opacity-50 border border-green-800 rounded p-4">
                        <p class="text-xs text-gray-400">Network Status</p>
                        <p class="text-lg font-bold text-green-400"><span id="chat-peers">0</span> Nodes Online</p>
                    </div>
                    <div class="bg-black bg-opacity-50 border border-green-800 rounded p-4">
                        <p class="text-xs text-gray-400">Your Balance</p>
                        <p class="text-lg font-bold text-green-400"><span id="chat-balance">0</span> GEN</p>
            </div>
        </div>

                <!-- Info Banner -->
                <div class="bg-black bg-opacity-30 border border-green-800 rounded p-4 text-center text-xs text-gray-400">
                    <p>‚ú® This AI runs on a decentralized network. No central server. No censorship.</p>
                    <p class="mt-2">Want to earn GEN tokens? Switch to <span class="text-green-400 font-bold">MINER</span> tab!</p>
                </div>
            </div>
        </div>

        <!-- ========================================== -->
        <!-- ‚õèÔ∏è MINER TAB (Node Dashboard) -->
        <!-- ========================================== -->
        <div id="tab-miner" class="tab-content p-6" style="background: linear-gradient(to bottom, #001a1a, #000000);">
            
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
        
        <!-- Left: P2P Network Status -->
        <div class="md:col-span-1 space-y-4">
            
            <!-- Connection Status -->
            <div class="neon-border p-4 bg-black bg-opacity-50">
                <h2 class="text-lg neon-text mb-3">üåê P2P NETWORK</h2>
                
                <!-- Share Button -->
                <button id="share-btn" class="w-full mb-3 py-2 bg-blue-900 hover:bg-blue-700 text-white text-sm font-bold border border-blue-500 transition-colors" disabled>
                    üìã COPY INVITE LINK
                </button>
                
                <!-- Manual Connect -->
                <details class="mb-3">
                    <summary class="text-xs text-cyan-400 cursor-pointer hover:text-cyan-300">
                        üîó Manual Connect (if auto-connect fails)
                    </summary>
                    <div class="mt-2 p-2 bg-gray-900 rounded">
                        <input type="text" id="manual-peer-id" placeholder="Paste Peer ID here..." 
                               class="w-full text-xs p-1 bg-black border border-gray-700 text-white mb-1">
                        <button id="manual-connect-btn" class="w-full text-xs py-1 bg-green-800 hover:bg-green-700 text-white">
                            Connect
                        </button>
                    </div>
                </details>
                
                <div class="space-y-2 text-sm">
                    <div class="flex justify-between items-center">
                        <span class="text-gray-400">My Peer ID</span>
                        <button id="copy-peer-id" class="font-mono text-xs hover:text-cyan-400 cursor-pointer transition-colors" title="Click to copy full Peer ID">
                            <span id="my-peer-id">-</span>
                        </button>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">Connected Peers</span>
                        <span id="connected-peers" class="font-bold text-green-400">0</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">Network Nodes</span>
                        <span id="total-nodes" class="font-bold">0</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">Global Best Loss</span>
                        <span id="global-loss" class="font-bold text-yellow-400">-</span>
                    </div>
            </div>
            
                <div class="mt-4 pt-4 border-t border-gray-700">
                    <p class="text-xs text-gray-400 mb-2">Connected Peers:</p>
                    <div id="peer-list" class="space-y-1 max-h-32 overflow-y-auto terminal-scroll">
                        <p class="text-xs text-gray-500">No peers connected</p>
                        <p class="text-xs text-cyan-400 mt-2">üí° Tip: Open another tab - Auto-connects!</p>
                </div>
            </div>
            
            <!-- Storage Management -->
            <div class="neon-border p-4 bg-black bg-opacity-50">
                <h2 class="text-lg neon-text mb-3">üíæ STORAGE</h2>
                <div class="space-y-2 text-xs">
                    <div class="flex justify-between">
                        <span class="text-gray-400">Used Space</span>
                        <span id="storage-used" class="font-bold text-yellow-400">-</span>
                    </div>
                    <button id="cleanup-btn" class="w-full py-2 bg-red-900 hover:bg-red-700 text-white text-xs font-bold border border-red-500 transition-colors">
                        üßπ CLEAR CACHE
                    </button>
                    <p class="text-gray-500 text-xs">Clears blockchain cache (will re-sync from network)</p>
                </div>
            </div>
        </div>

            <!-- Mining Control -->
            <div class="neon-border p-4 bg-black bg-opacity-50 text-center">
                <h2 class="text-xl font-bold mb-4">‚öôÔ∏è MINING CONTROL</h2>
                <button id="mine-btn" class="w-full py-4 bg-transparent border-2 border-green-500 text-green-500 font-bold text-xl hover:bg-green-500 hover:text-black transition-all duration-200 shadow-[0_0_15px_#00FF00]">
                    START DISTRIBUTED LEARNING
                </button>
                <p id="status-text" class="mt-3 text-sm">
                    Status: <span class="text-red-500">OFFLINE</span>
                </p>
            </div>

            <!-- Stats -->
            <div class="neon-border p-4 bg-black bg-opacity-50">
                <h2 class="text-lg neon-text mb-3">üìä LOCAL STATS</h2>
                <div class="space-y-2 text-sm">
                    <div class="flex justify-between">
                        <span class="text-gray-400">Local Epochs</span>
                        <span id="epochs" class="font-bold">0</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">Best Local Loss</span>
                        <span id="local-loss" class="font-bold text-blue-400">-</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">Model Params</span>
                        <span id="model-params" class="font-bold">-</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">‚õìÔ∏è Blockchain Height</span>
                        <span id="blocks-received" class="font-bold text-purple-400">0</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">üåç Network Miners</span>
                        <span id="network-miners" class="font-bold text-cyan-400">0</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">üíé Total GEN Mined</span>
                        <span id="total-mined" class="font-bold text-yellow-400">0</span>
                    </div>
                    <div class="flex justify-between border-t border-gray-700 pt-2 mt-2">
                        <span class="text-gray-400" title="Higher = Smarter AI (more parameters)">üß¨ Your Generation</span>
                        <span id="brain-generation" class="font-bold text-green-400">-</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400" title="Network's current AI generation">üåê Network Generation</span>
                        <span id="network-generation" class="font-bold text-cyan-400">
                            <span id="network-gen-value">-</span>
                            <span id="sync-warning" class="text-xs text-red-400 hidden">‚ö†Ô∏è SYNC</span>
                        </span>
                    </div>
                    <div class="text-xs text-gray-500 mt-1 italic">
                        üí° Higher generation = More intelligent AI
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">üìà Next Evolution</span>
                        <span id="evolution-progress" class="font-bold text-gray-400">0/10 blocks</span>
                    </div>
                    </div>
                </div>
            </div>

        <!-- Middle: Training Visualization -->
        <div class="md:col-span-2 space-y-4">
            
            <!-- Loss Chart -->
            <div class="neon-border p-4 bg-black bg-opacity-50 h-80">
                <h2 class="text-lg neon-text mb-2">üß† NEURAL EVOLUTION (LOSS)</h2>
                <canvas id="lossChart"></canvas>
                    </div>
            
            <!-- Current Learning Data -->
            <div class="neon-border p-4 bg-black bg-opacity-50">
                <h2 class="text-lg neon-text mb-2">üìñ CURRENTLY LEARNING</h2>
                <div id="learning-preview" class="text-xs p-3 bg-gray-900 bg-opacity-50 text-gray-300 italic rounded h-24 overflow-y-auto terminal-scroll">
                    <span class="text-gray-500">No data yet...</span>
                    </div>
                    </div>
            
            <!-- Data Sources Performance -->
            <div class="neon-border p-4 bg-black bg-opacity-50">
                <h2 class="text-lg neon-text mb-2">üçΩÔ∏è DATA SOURCES (Autonomous Foraging)</h2>
                <div id="data-sources" class="text-xs space-y-1">
                    <div class="text-gray-500">Initializing...</div>
                    </div>
                </div>
            
            <!-- Collaboration Status -->
            <div class="neon-border p-4 bg-black bg-opacity-50">
                <h2 class="text-lg neon-text mb-2">ü§ù COLLABORATION STATUS</h2>
                <div class="space-y-2">
                    <div class="flex justify-between items-center p-2 bg-gray-900 bg-opacity-50 rounded">
                        <span class="text-xs text-gray-400">Weights Received</span>
                        <span id="weights-received" class="text-sm font-bold text-blue-400">0</span>
            </div>
                    <div class="flex justify-between items-center p-2 bg-gray-900 bg-opacity-50 rounded">
                        <span class="text-xs text-gray-400">Gradients Shared</span>
                        <span id="gradients-shared" class="text-sm font-bold text-green-400">0</span>
        </div>
                    <div class="flex justify-between items-center p-2 bg-gray-900 bg-opacity-50 rounded">
                        <span class="text-xs text-gray-400">Blocks Contributed</span>
                        <span id="blocks-contributed" class="text-sm font-bold text-yellow-400">0</span>
                    </div>
                    <div class="p-2 bg-green-900 bg-opacity-20 border border-green-800 rounded mt-3">
                        <p class="text-xs text-green-300 text-center">
                            ‚ú® <span id="collaboration-status">All nodes learning together!</span>
                        </p>
                    </div>
                </div>
            </div>
            
            <!-- P2P Activity Feed -->
            <div class="neon-border p-4 bg-black bg-opacity-50 flex flex-col">
                <h2 class="text-lg neon-text mb-2">üì° P2P ACTIVITY LOG</h2>
                <div id="activity-feed" class="terminal-scroll flex-grow overflow-y-auto h-48 text-xs space-y-1 p-2 bg-gray-900 bg-opacity-30 font-mono">
                    <p class="text-gray-500">> System initialized in Pure P2P mode</p>
                    <p class="text-gray-500">> No central server - all data P2P synchronized</p>
                    </div>
                </div>
            
            </div>
        </div>
        
        <!-- ========================================== -->
        <!-- üîç EXPLORER TAB (Blockchain Viewer) -->
        <!-- ========================================== -->
        <div id="tab-explorer" class="tab-content hidden p-6" style="background: linear-gradient(to bottom, #0a0a0a, #000000);">
            
            <div class="max-w-7xl mx-auto space-y-4">
                
                <!-- Blockchain Summary -->
                <div class="grid grid-cols-4 gap-4 mb-6">
                    <div class="bg-gradient-to-br from-gray-800 to-black border border-gray-600 rounded p-4">
                        <p class="text-xs text-gray-400">‚õìÔ∏è Chain Height</p>
                        <p class="text-2xl font-bold text-white"><span id="explorer-height">0</span></p>
                    </div>
                    <div class="bg-gradient-to-br from-gray-800 to-black border border-gray-600 rounded p-4">
                        <p class="text-xs text-gray-400">üë• Network Miners</p>
                        <p class="text-2xl font-bold text-cyan-400"><span id="explorer-miners">0</span></p>
                    </div>
                    <div class="bg-gradient-to-br from-gray-800 to-black border border-gray-600 rounded p-4">
                        <p class="text-xs text-gray-400">üíé Total Mined</p>
                        <p class="text-2xl font-bold text-yellow-400"><span id="explorer-total">0</span> GEN</p>
                    </div>
                    <div class="bg-gradient-to-br from-gray-800 to-black border border-gray-600 rounded p-4">
                        <p class="text-xs text-gray-400">üß† Best Loss</p>
                        <p class="text-2xl font-bold text-green-400"><span id="explorer-loss">-</span></p>
                    </div>
                </div>
                
                <!-- Blockchain Table -->
                <div class="bg-black bg-opacity-50 border-2 border-gray-700 rounded-lg p-6">
                    <h2 class="text-xl font-bold mb-4 text-white">üìú Blockchain Ledger</h2>
                    <div class="overflow-x-auto">
                        <table class="w-full text-sm text-left">
                            <thead class="text-xs uppercase bg-gray-900 text-gray-400">
                                <tr>
                                    <th class="px-4 py-3">Block #</th>
                                    <th class="px-4 py-3">Timestamp</th>
                                    <th class="px-4 py-3">Miner</th>
                                    <th class="px-4 py-3">Loss</th>
                                    <th class="px-4 py-3">Reward</th>
                                    <th class="px-4 py-3">Hash</th>
                                </tr>
                            </thead>
                            <tbody id="blockchain-table" class="text-gray-300">
                                <tr class="border-b border-gray-800">
                                    <td colspan="6" class="px-4 py-8 text-center text-gray-500">
                                        No blocks yet. Start mining to create the first block!
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
                
                <!-- Global Ledger (Balances) -->
                <div class="bg-black bg-opacity-50 border-2 border-gray-700 rounded-lg p-6">
                    <h2 class="text-xl font-bold mb-4 text-white">üí∞ Global Ledger (All Balances)</h2>
                    <div class="overflow-x-auto">
                        <table class="w-full text-sm text-left">
                            <thead class="text-xs uppercase bg-gray-900 text-gray-400">
                                <tr>
                                    <th class="px-4 py-3">Rank</th>
                                    <th class="px-4 py-3">Wallet Address</th>
                                    <th class="px-4 py-3">Balance</th>
                                    <th class="px-4 py-3">% of Total</th>
                                </tr>
                            </thead>
                            <tbody id="ledger-table" class="text-gray-300">
                                <tr class="border-b border-gray-800">
                                    <td colspan="4" class="px-4 py-8 text-center text-gray-500">
                                        No transactions yet.
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
        
    </div> <!-- End Container -->

    <script>
        // ============================================
        // PURE P2P GENESIS AI - ZERO SERVER ARCHITECTURE
        // ============================================
        
        console.log("üöÄ Initializing Pure P2P Genesis AI...");
        
        // ============================================
        // TAB NAVIGATION SYSTEM
        // ============================================
        
        let currentTab = 'miner'; // Default tab
        
        function switchTab(tabName) {
            currentTab = tabName;
            
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.add('hidden');
            });
            
            // Show selected tab
            document.getElementById(`tab-${tabName}`).classList.remove('hidden');
            
            // Update button states
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
                btn.style.borderBottomColor = 'transparent';
                btn.style.background = 'transparent';
            });
            
            const activeBtn = document.querySelector(`[data-tab="${tabName}"]`);
            activeBtn.classList.add('active');
            
            // Apply tab-specific styling
            switch(tabName) {
                case 'chat':
                    activeBtn.style.borderBottomColor = '#00FF88';
                    activeBtn.style.background = 'rgba(0, 255, 136, 0.1)';
                    break;
                case 'miner':
                    activeBtn.style.borderBottomColor = '#00FFFF';
                    activeBtn.style.background = 'rgba(0, 255, 255, 0.1)';
                    break;
                case 'explorer':
                    activeBtn.style.borderBottomColor = '#FFFFFF';
                    activeBtn.style.background = 'rgba(255, 255, 255, 0.1)';
                    break;
            }
            
            // Update tab-specific data
            updateTabData(tabName);
        }
        
        function updateTabData(tabName) {
            if (tabName === 'chat') {
                // Update chat tab data
                document.getElementById('chat-peers').innerText = Object.keys(connections).length;
                document.getElementById('chat-balance').innerText = balance.toFixed(2);
            } else if (tabName === 'explorer') {
                // Update explorer tab data
                updateExplorerView();
            }
        }
        
        function updateExplorerView() {
            // Update blockchain table
            const tableBody = document.getElementById('blockchain-table');
            const blocks = blockchain.chain.slice().reverse(); // Newest first
            
            if (blocks.length <= 1) {
                tableBody.innerHTML = `
                    <tr class="border-b border-gray-800">
                        <td colspan="6" class="px-4 py-8 text-center text-gray-500">
                            No blocks yet. Start mining to create the first block!
                        </td>
                    </tr>`;
            } else {
                tableBody.innerHTML = blocks.slice(1).map(block => {
                    const date = new Date(block.timestamp).toLocaleString();
                    const minerShort = block.miner ? block.miner.substring(0, 8) + '...' : 'Genesis';
                    const hashShort = block.hash.substring(0, 12) + '...';
                    
                    return `
                        <tr class="border-b border-gray-800 hover:bg-gray-900">
                            <td class="px-4 py-3 font-bold text-cyan-400">${block.index}</td>
                            <td class="px-4 py-3 text-xs">${date}</td>
                            <td class="px-4 py-3 font-mono text-xs">${minerShort}</td>
                            <td class="px-4 py-3 text-yellow-400">${block.loss ? block.loss.toFixed(4) : '-'}</td>
                            <td class="px-4 py-3 text-green-400">${block.reward || 0} GEN</td>
                            <td class="px-4 py-3 font-mono text-xs">${hashShort}</td>
                        </tr>
                    `;
                }).join('');
            }
            
            // Update global ledger table
            const ledgerBody = document.getElementById('ledger-table');
            const ledgerEntries = Object.entries(globalLedger).sort((a, b) => b[1] - a[1]);
            const totalSupply = ledgerEntries.reduce((sum, [_, bal]) => sum + bal, 0);
            
            if (ledgerEntries.length === 0) {
                ledgerBody.innerHTML = `
                    <tr class="border-b border-gray-800">
                        <td colspan="4" class="px-4 py-8 text-center text-gray-500">
                            No transactions yet.
                        </td>
                    </tr>`;
            } else {
                ledgerBody.innerHTML = ledgerEntries.map(([wallet, bal], idx) => {
                    const walletShort = wallet.substring(0, 12) + '...';
                    const percentage = totalSupply > 0 ? ((bal / totalSupply) * 100).toFixed(2) : 0;
                    const isMe = wallet === walletAddress;
                    
                    return `
                        <tr class="border-b border-gray-800 hover:bg-gray-900 ${isMe ? 'bg-green-900 bg-opacity-20' : ''}">
                            <td class="px-4 py-3 font-bold">${idx + 1}</td>
                            <td class="px-4 py-3 font-mono text-xs ${isMe ? 'text-green-400 font-bold' : ''}">${walletShort} ${isMe ? '(You)' : ''}</td>
                            <td class="px-4 py-3 text-yellow-400 font-bold">${bal.toFixed(2)} GEN</td>
                            <td class="px-4 py-3 text-gray-400">${percentage}%</td>
                        </tr>
                    `;
                }).join('');
            }
            
            // Update summary stats
            document.getElementById('explorer-height').innerText = blockchain.getBlockchainHeight();
            document.getElementById('explorer-miners').innerText = Object.keys(globalLedger).length;
            document.getElementById('explorer-total').innerText = totalSupply.toFixed(2);
            document.getElementById('explorer-loss').innerText = localBestLoss < 9.9 ? localBestLoss.toFixed(4) : '-';
        }
        
        // Setup tab navigation
        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    switchTab(btn.dataset.tab);
                });
            });
            
            // Show default tab
            switchTab('miner');
        });
        
        // --- Configuration ---
        const SEQUENCE_LENGTH = 10;
        const MODEL_VERSION = 'BiLSTM_v2'; // Model architecture version (for compatibility check)
        const VOCAB = 'abcdefghijklmnopqrstuvwxyz .';
        const vocab = VOCAB.split('');
        const charToIndex = {};
        const indexToChar = {};
        vocab.forEach((c, i) => {
            charToIndex[c] = i;
            indexToChar[i] = c;
        });
        
        const MAX_PEERS = 5; // Connect to maximum 5 peers
        const GOSSIP_INTERVAL = 5000; // Broadcast state every 5 seconds
        const TRAINING_DATA_LENGTH = 200; // Length of training text
        
        // --- üéØ Triple Reward System ---
        const REWARD_PER_EPOCH = 0.01;      // Per-epoch reward (PoW - Computation contribution)
        const BLOCK_WIN_REWARD = 5.0;       // Block creation bonus (PoW - Performance reward)
        const VALIDATION_REWARD = 0.1;      // Block validation reward (PoV - Validator reward)
        const VALIDATION_THRESHOLD = 0.05;  // Validation error tolerance (Anti-fraud)
        
        // --- Wallet & Security ---
        const EC = elliptic.ec;
        const ec = new EC('secp256k1');
        
        let keyPair, privateKey, publicKey, walletAddress;
        
        function initWallet() {
            const saved = localStorage.getItem('p2p_genesis_wallet');
            if (saved) {
                privateKey = saved;
                keyPair = ec.keyFromPrivate(privateKey);
                console.log("üîê Wallet restored from localStorage");
            } else {
                keyPair = ec.genKeyPair();
                privateKey = keyPair.getPrivate('hex');
                localStorage.setItem('p2p_genesis_wallet', privateKey);
                console.log("üÜï New wallet generated");
            }
            publicKey = keyPair.getPublic('hex');
            walletAddress = "P2P_" + publicKey.substring(0, 12).toUpperCase();
            document.getElementById('wallet-address').innerText = walletAddress;
        }
        
        initWallet();
        
        // --- Balance Management ---
        let balance = 0;
        
        // --- Collaboration Statistics ---
        let collaborationStats = {
            weightsReceived: 0,
            gradientsShared: 0,
            blocksContributed: 0
        };
        
        function loadCollaborationStats() {
            try {
                const saved = localStorage.getItem('p2p_collab_stats');
                if (saved) {
                    collaborationStats = JSON.parse(saved);
                    updateCollaborationUI();
                }
            } catch(e) {
                console.error("Failed to load collaboration stats:", e);
            }
        }
        
        function saveCollaborationStats() {
            try {
                localStorage.setItem('p2p_collab_stats', JSON.stringify(collaborationStats));
            } catch(e) {
                console.error("Failed to save collaboration stats:", e);
            }
        }
        
        function updateCollaborationUI() {
            document.getElementById('weights-received').innerText = collaborationStats.weightsReceived;
            document.getElementById('gradients-shared').innerText = collaborationStats.gradientsShared;
            document.getElementById('blocks-contributed').innerText = collaborationStats.blocksContributed;
            
            // Update status message
            const total = collaborationStats.weightsReceived + collaborationStats.gradientsShared + collaborationStats.blocksContributed;
            const statusEl = document.getElementById('collaboration-status');
            
            if (total === 0) {
                statusEl.innerText = "Waiting to connect with network...";
            } else if (total < 5) {
                statusEl.innerText = "Starting to collaborate!";
            } else if (total < 20) {
                statusEl.innerText = "Actively learning together!";
            } else {
                statusEl.innerText = `Contributing to collective intelligence! (${total} interactions)`;
            }
        }
        
        function loadBalance() {
            const saved = localStorage.getItem('p2p_balance');
            if (saved) {
                balance = parseFloat(saved);
            } else {
                balance = 0;
            }
            updateBalanceUI();
        }
        
        function addBalance(amount) {
            balance += amount;
            localStorage.setItem('p2p_balance', balance.toString());
            updateBalanceUI();
            console.log(`üí∞ Balance updated: +${amount} GEN (Total: ${balance})`);
        }
        
        function updateBalanceUI() {
            document.getElementById('balance').innerText = balance.toFixed(2);
            
            // Update Global Ledger Stats (safe handling)
            if (typeof globalLedger !== 'undefined' && globalLedger) {
                const minerCount = Object.keys(globalLedger).length;
                const totalMined = Object.values(globalLedger).reduce((a, b) => a + b, 0);
                
                document.getElementById('network-miners').innerText = minerCount;
                document.getElementById('total-mined').innerText = totalMined.toFixed(2);
            } else {
                document.getElementById('network-miners').innerText = '0';
                document.getElementById('total-mined').innerText = '0.00';
            }
        }
        
        // --- P2P Network State ---
        let peer = null;
        let myPeerId = null;
        let connections = {}; // {peerId: connection}
        
        // üîÑ BroadcastChannel for same-browser tab discovery
        let tabChannel = null;
        
        function initTabDiscovery() {
            try {
                tabChannel = new BroadcastChannel('genesis-ai-tabs');
                
                // Listen for other tabs announcing their Peer IDs
                tabChannel.onmessage = (event) => {
                    const { type, peerId, timestamp } = event.data;
                    
                    if (type === 'peer_announce' && peerId && peerId !== myPeerId) {
                        console.log(`üì± Discovered peer in another tab: ${peerId.substring(0, 8)}`);
                        
                        // Don't spam connections
                        if (!connections[peerId]) {
                            addLog(`üì± Auto-connecting to peer in another tab...`, "info");
                            setTimeout(() => connectToPeer(peerId), 500);
                        }
                    }
                };
                
                console.log("üì± Tab discovery channel initialized");
            } catch(e) {
                console.warn("BroadcastChannel not supported:", e);
            }
            
            // üîÑ Alternative: localStorage-based discovery (more reliable)
            registerTabInStorage();
            scanForOtherTabs();
        }
        
        function registerTabInStorage() {
            if (!myPeerId) return;
            
            try {
                // Get existing tabs
                const tabsData = localStorage.getItem('genesis_active_tabs');
                const tabs = tabsData ? JSON.parse(tabsData) : {};
                
                // Add this tab
                tabs[myPeerId] = {
                    peerId: myPeerId,
                    timestamp: Date.now(),
                    sessionId: Date.now() + Math.random()
                };
                
                // Clean old tabs (older than 30 seconds)
                const now = Date.now();
                Object.keys(tabs).forEach(id => {
                    if (now - tabs[id].timestamp > 30000) {
                        console.log(`üßπ Removing stale tab: ${id.substring(0, 8)}`);
                        delete tabs[id];
                    }
                });
                
                localStorage.setItem('genesis_active_tabs', JSON.stringify(tabs));
                
                const otherTabs = Object.keys(tabs).filter(id => id !== myPeerId);
                console.log(`üìù Registered in localStorage: ${Object.keys(tabs).length} tab(s) total, ${otherTabs.length} other(s)`);
                
                // Show in UI
                if (otherTabs.length === 0) {
                    console.log(`üí° No other tabs found. Open another tab at: ${window.location.origin}`);
                }
            } catch(e) {
                console.error("Failed to register tab:", e);
                if (e.name === 'QuotaExceededError') {
                    console.log("üßπ localStorage full, clearing active tabs...");
                    localStorage.removeItem('genesis_active_tabs');
                }
            }
        }
        
        function scanForOtherTabs() {
            try {
                const tabsData = localStorage.getItem('genesis_active_tabs');
                if (!tabsData) return;
                
                const tabs = JSON.parse(tabsData);
                const otherPeers = Object.keys(tabs).filter(id => id !== myPeerId);
                
                console.log(`üîç Scanning for tabs: Found ${otherPeers.length} other tab(s)`);
                
                otherPeers.forEach(peerId => {
                    if (!connections[peerId]) {
                        console.log(`üîó Connecting to tab: ${peerId.substring(0, 8)}`);
                        addLog(`üì± Found peer in another tab: ${peerId.substring(0, 8)}...`, "info");
                        setTimeout(() => connectToPeer(peerId), 500);
                    }
                });
            } catch(e) {
                console.error("Failed to scan tabs:", e);
            }
        }
        
        function announceToOtherTabs() {
            // BroadcastChannel announcement
            if (tabChannel && myPeerId) {
                tabChannel.postMessage({
                    type: 'peer_announce',
                    peerId: myPeerId,
                    timestamp: Date.now()
                });
            }
            
            // localStorage registration (backup method)
            registerTabInStorage();
        }
        
        // Periodic tab scanning
        setInterval(() => {
            if (myPeerId) {
                registerTabInStorage();
                scanForOtherTabs();
            }
        }, 3000); // Every 3 seconds
        let networkState = {
            bestLoss: 9.9,
            bestWeights: null,
            blocksReceived: 0
        };
        
        // ============================================
        // IPFS INTEGRATION (Helia - Decentralized Storage)
        // ============================================
        
        let heliaNode = null;
        let unixfs = null;
        
        async function initIPFS() {
            try {
                console.log("üì¶ Initializing IPFS Node (Helia)...");
                
                // ‚ö†Ô∏è TEMPORARY DISABLED: Browser IPFS causes libp2p WebSocket errors
                // IPFS in pure browser environment has limitations with libp2p connections
                // Using P2P direct transfer instead (more stable for now)
                
                console.log("‚ö†Ô∏è IPFS disabled - using P2P direct transfer");
                addLog("üì¶ Using P2P direct transfer (IPFS disabled for stability)", "info");
                
                // Uncomment below to enable IPFS (may cause WebSocket errors):
                /*
                heliaNode = await window.Helia.createHelia({
                    libp2p: {
                        config: {
                            transport: {
                                // Disable problematic transports
                                websocket: false
                            }
                        }
                    }
                });
                unixfs = await window.HeliaUnixfs.unixfs(heliaNode);
                addLog("üì¶ IPFS Node initialized", "success");
                */
            } catch (e) {
                console.error("‚ùå IPFS Init Error:", e);
                addLog("‚ö†Ô∏è IPFS initialization failed (using P2P fallback)", "warn");
            }
        }
        
        // Upload data to IPFS and return CID (Content Identifier)
        async function uploadToIPFS(data) {
            if (!heliaNode || !unixfs) {
                console.warn("‚ö†Ô∏è IPFS not available, returning null");
                return null;
            }
            
            try {
                const dataString = JSON.stringify(data);
                const encoder = new TextEncoder();
                const bytes = encoder.encode(dataString);
                
                // Add to IPFS
                const cid = await unixfs.addBytes(bytes);
                
                console.log(`üì§ Uploaded to IPFS: ${cid.toString()} (${(bytes.length / 1024).toFixed(2)} KB)`);
                return cid.toString();
            } catch (e) {
                console.error("‚ùå IPFS Upload Error:", e);
                return null;
            }
        }
        
        // Download data from IPFS using CID
        async function downloadFromIPFS(cidString) {
            if (!heliaNode || !unixfs) {
                console.warn("‚ö†Ô∏è IPFS not available");
                return null;
            }
            
            try {
                console.log(`üì• Downloading from IPFS: ${cidString}`);
                
                // Parse CID
                const cid = window.Helia.CID.parse(cidString);
                
                // Download bytes
                const chunks = [];
                for await (const chunk of unixfs.cat(cid)) {
                    chunks.push(chunk);
                }
                
                // Combine chunks
                const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
                const combined = new Uint8Array(totalLength);
                let offset = 0;
                for (const chunk of chunks) {
                    combined.set(chunk, offset);
                    offset += chunk.length;
                }
                
                // Decode and parse
                const decoder = new TextDecoder();
                const dataString = decoder.decode(combined);
                const data = JSON.parse(dataString);
                
                console.log(`‚úÖ Downloaded from IPFS: ${(combined.length / 1024).toFixed(2)} KB`);
                return data;
            } catch (e) {
                console.error("‚ùå IPFS Download Error:", e);
                return null;
            }
        }
        
        // --- Global Ledger (Distributed Ledger) ---
        let globalLedger = {}; // {walletAddress: balance} - Balance records of all participants
        
        function initGlobalLedger() {
            const saved = localStorage.getItem('p2p_global_ledger');
            if (saved) {
                globalLedger = JSON.parse(saved);
                console.log("üìÇ Global Ledger loaded:", Object.keys(globalLedger).length, "accounts");
            } else {
                globalLedger = {};
                globalLedger[walletAddress] = balance; // Register my account
            }
        }
        
        function saveGlobalLedger() {
            localStorage.setItem('p2p_global_ledger', JSON.stringify(globalLedger));
        }
        
        function updateGlobalLedger(minerAddress, reward) {
            globalLedger[minerAddress] = (globalLedger[minerAddress] || 0) + reward;
            saveGlobalLedger();
        }
        
        // Calculate Weights Hash (for blockchain verification)
        function hashWeights(weights) {
            if (!weights || weights.length === 0) return "0000000000000000";
            const sum = weights.map(w => w.data.reduce((a, b) => a + b, 0))
                .reduce((a, b) => a + b, 0);
            return Math.abs(sum).toString(16).substring(0, 16).padStart(16, '0');
        }
        
        // ============================================
        // BLOCKCHAIN IMPLEMENTATION
        // ============================================
        
        class Block {
            constructor(index, timestamp, previousHash, data) {
                this.index = index;
                this.timestamp = timestamp;
                this.previousHash = previousHash;
                this.miner = data.miner;
                this.loss = data.loss;
                this.weightsHash = data.weightsHash;
                this.peerId = data.peerId;
                this.reward = data.reward || 0;
                
                // üîê Include verification data (PoV - Proof of Validation)
                this.weights = data.weights || null;         // Full weights (verifiable) - Fallback if IPFS fails
                this.weightsCID = data.weightsCID || null;   // IPFS CID for weights (preferred)
                this.trainingData = data.trainingData || ""; // Training data evidence
                
                // üîñ Model compatibility tracking
                this.modelVersion = data.modelVersion || 'unknown'; // Architecture version
                this.generation = data.generation || 1;             // Evolution generation
                
                this.hash = this.calculateHash();
            }
            
            calculateHash() {
                const data = this.index + this.timestamp + this.previousHash + 
                            this.miner + this.loss + this.weightsHash + this.reward;
                // Simple hash (in production, use SHA-256)
                let hash = 0;
                for (let i = 0; i < data.length; i++) {
                    const char = data.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash;
                }
                return Math.abs(hash).toString(16).padStart(16, '0');
            }
        }
        
        class Blockchain {
            constructor() {
                this.chain = this.loadChain() || [this.createGenesisBlock()];
                this.saveChain();
            }
            
            createGenesisBlock() {
                return new Block(0, Date.now(), "0", {
                    miner: "GENESIS",
                    loss: 9.9,
                    weightsHash: "0000000000000000",
                    peerId: "SYSTEM",
                    reward: 0,
                    weights: null,
                    trainingData: "Genesis Block - The Beginning"
                });
            }
            
            getLatestBlock() {
                return this.chain[this.chain.length - 1];
            }
            
            addBlock(data) {
                const previousBlock = this.getLatestBlock();
                const newBlock = new Block(
                    previousBlock.index + 1,
                    Date.now(),
                    previousBlock.hash,
                    data
                );
                
                // Validate before adding
                if (this.isValidNewBlock(newBlock, previousBlock)) {
                    this.chain.push(newBlock);
                    this.saveChain();
                    
                    // Broadcast to network
                    this.broadcastBlock(newBlock);
                    
                    console.log(`‚õìÔ∏è Block #${newBlock.index} added to chain`);
                    return newBlock;
                }
                return null;
            }
            
            isValidNewBlock(newBlock, previousBlock) {
                // Validation 1: Is block index sequential?
                if (previousBlock.index + 1 !== newBlock.index) {
                    console.warn("‚ùå Invalid index:", newBlock.index, "expected:", previousBlock.index + 1);
                    return false;
                }
                
                // Validation 2: Is it connected to previous block?
                if (previousBlock.hash !== newBlock.previousHash) {
                    console.warn("‚ùå Invalid previous hash");
                    return false;
                }
                
                // Validation 3: Is block hash accurate?
                if (newBlock.calculateHash() !== newBlock.hash) {
                    console.warn("‚ùå Invalid hash");
                    return false;
                }
                
                // Validation 4: Is intelligence actually improved? (Is Loss lower?)
                if (newBlock.index > 0 && newBlock.loss >= previousBlock.loss) {
                    console.warn("‚ùå Loss not improved:", newBlock.loss, ">=", previousBlock.loss);
                    return false;
                }
                
                return true;
            }
            
            isValidChain(chain) {
                if (JSON.stringify(chain[0]) !== JSON.stringify(this.createGenesisBlock())) {
                    return false;
                }
                
                for (let i = 1; i < chain.length; i++) {
                    const block = Object.assign(new Block(0, 0, "0", {}), chain[i]);
                    const previousBlock = chain[i - 1];
                    
                    if (!this.isValidNewBlock(block, previousBlock)) {
                        return false;
                    }
                }
                return true;
            }
            
            replaceChain(newChain) {
                if (newChain.length > this.chain.length && this.isValidChain(newChain)) {
                    const oldHeight = this.getBlockchainHeight();
                    console.log(`üîÑ Replacing chain: ${this.chain.length} ‚Üí ${newChain.length} blocks (Height: ${oldHeight} ‚Üí ${newChain.length - 1})`);
                    
                    this.chain = newChain;
                    this.saveChain();
                    
                    const newHeight = this.getBlockchainHeight();
                    
                    // Update UI immediately
                    document.getElementById('blocks-received').innerText = newHeight;
                    
                    // üß¨ Check if generation changed due to chain replacement
                    const oldGen = getGenerationFromBlockHeight(oldHeight);
                    const newGen = getGenerationFromBlockHeight(newHeight);
                    
                    console.log(`üìä Generation check: ${oldGen} ‚Üí ${newGen}`);
                    
                    // Update network generation display
                    const genText = ['1st', '2nd', '3rd'];
                    const netGenText = newGen <= 3 ? genText[newGen - 1] : `${newGen}th`;
                    const networkGenEl = document.getElementById('network-gen-value');
                    if (networkGenEl) {
                        networkGenEl.innerText = `${netGenText} Gen`;
                    }
                    
                    if (oldGen !== newGen) {
                        addLog(`üîÑ Network updated to Generation ${newGen}`, "info");
                        
                        if (model && isMining && currentGeneration !== newGen) {
                            console.log(`‚ö†Ô∏è Your generation (${currentGeneration}) differs from network (${newGen})`);
                            addLog(`‚ö†Ô∏è You are on Gen ${currentGeneration}, but network is Gen ${newGen}. Restart mining!`, "warn");
                            
                            // Show sync warning
                            const syncWarning = document.getElementById('sync-warning');
                            if (syncWarning) {
                                syncWarning.classList.remove('hidden');
                            }
                        }
                    }
                    
                    return true;
                }
                return false;
            }
            
            saveChain() {
                try {
                    localStorage.setItem('p2p_blockchain', JSON.stringify(this.chain));
                } catch(e) {
                    console.error("Failed to save blockchain:", e);
                }
            }
            
            loadChain() {
                try {
                    const saved = localStorage.getItem('p2p_blockchain');
                    if (saved) {
                        const chain = JSON.parse(saved);
                        console.log(`üìÇ Loaded blockchain: ${chain.length} blocks`);
                        return chain;
                    }
                } catch(e) {
                    console.error("Failed to load blockchain:", e);
                }
                return null;
            }
            
            broadcastBlock(block) {
                Object.values(connections).forEach(conn => {
                    try {
                        conn.send({
                            type: 'new_block',
                            block: block
                        });
                    } catch(e) {
                        console.error("Failed to broadcast block:", e);
                    }
                });
            }
            
            getBlockchainHeight() {
                return this.chain.length - 1; // Exclude genesis
            }
        }
        
        // Initialize blockchain
        let blockchain = new Blockchain();
        
        // Update UI
        document.getElementById('blocks-received').innerText = blockchain.getBlockchainHeight();
        
        // --- AI Model ---
        let model = null;
        let isMining = false;
        let epochCount = 0;
        let localBestLoss = 9.9;
        let lossHistory = [];
        
        // --- Evolution System ---
        let currentGeneration = 1;
        const EVOLUTION_INTERVAL = 10; // Evolution every 10 blocks
        
        // ============================================
        // FEDERATED LEARNING - Distributed Training
        // ============================================
        
        let gradientBuffer = {}; // {peerId: {gradients, timestamp}}
        const GRADIENT_AGGREGATION_INTERVAL = 5; // Aggregate every 5 epochs
        let lastGradientShare = 0;
        
        // Extract gradients from model (for sharing)
        function extractGradients() {
            if (!model) return null;
            
            const weights = model.getWeights();
            const gradients = weights.map(w => ({
                data: Array.from(w.dataSync()),
                shape: w.shape
            }));
            
            return gradients;
        }
        
        // Apply aggregated gradients to model
        async function applyAggregatedGradients(aggregatedGrads) {
            if (!model || !aggregatedGrads) return;
            
            try {
                const currentWeights = model.getWeights();
                const newWeights = [];
                
                for (let i = 0; i < currentWeights.length; i++) {
                    if (i < aggregatedGrads.length) {
                        // Average: current + aggregated gradients
                        const current = await currentWeights[i].array();
                        const grad = aggregatedGrads[i].data;
                        
                        // Simple gradient descent: w = w - learning_rate * gradient
                        const learningRate = 0.01;
                        const updated = current.map((val, idx) => {
                            return val - learningRate * (grad[idx] || 0);
                        });
                        
                        newWeights.push(tf.tensor(updated, currentWeights[i].shape));
                    } else {
                        newWeights.push(currentWeights[i]);
                    }
                }
                
                model.setWeights(newWeights);
                newWeights.forEach(w => w.dispose());
                
                console.log("‚úÖ Federated gradients applied");
            } catch (e) {
                console.error("Failed to apply gradients:", e);
            }
        }
        
        // Aggregate gradients from multiple peers (Federated Averaging)
        function aggregateGradients() {
            const peerGrads = Object.values(gradientBuffer);
            
            if (peerGrads.length === 0) return null;
            
            console.log(`üîÑ Aggregating gradients from ${peerGrads.length} peers`);
            
            // Average all gradients
            const aggregated = [];
            const numPeers = peerGrads.length;
            
            // Assume all peers have same model structure
            const numLayers = peerGrads[0].gradients.length;
            
            for (let layerIdx = 0; layerIdx < numLayers; layerIdx++) {
                const layerGrads = peerGrads.map(pg => pg.gradients[layerIdx]);
                const dataLength = layerGrads[0].data.length;
                const shape = layerGrads[0].shape;
                
                // Average across all peers
                const avgData = new Array(dataLength).fill(0);
                for (let i = 0; i < dataLength; i++) {
                    let sum = 0;
                    for (const grad of layerGrads) {
                        sum += grad.data[i] || 0;
                    }
                    avgData[i] = sum / numPeers;
                }
                
                aggregated.push({
                    data: avgData,
                    shape: shape
                });
            }
            
            // Clear buffer after aggregation
            gradientBuffer = {};
            
            return aggregated;
        }
        
        // Share my gradients with network
        function shareGradients() {
            const gradients = extractGradients();
            
            if (!gradients) return;
            
            console.log("üì§ Sharing gradients with network");
            
            broadcastToNetwork({
                type: 'gradients',
                gradients: gradients,
                peerId: myPeerId,
                timestamp: Date.now()
            });
            
            // ü§ù Update collaboration stats
            collaborationStats.gradientsShared++;
            saveCollaborationStats();
            updateCollaborationUI();
            
            lastGradientShare = epochCount;
        }
        
        // Handle received gradients from peers
        function handleGradients(peerId, data) {
            if (!data.gradients) return;
            
            // Store in buffer for aggregation
            gradientBuffer[peerId] = {
                gradients: data.gradients,
                timestamp: data.timestamp
            };
            
            console.log(`üì• Received gradients from ${peerId.substring(0, 8)} (Buffer: ${Object.keys(gradientBuffer).length})`);
            
            // If we have enough gradients, aggregate and apply
            if (Object.keys(gradientBuffer).length >= 3) {
                const aggregated = aggregateGradients();
                if (aggregated) {
                    applyAggregatedGradients(aggregated);
                    addLog(`ü§ù Federated learning: Averaged gradients from ${Object.keys(gradientBuffer).length} peers`, "success");
                }
            }
        }
        
        function getGenerationFromBlockHeight(blockHeight) {
            return Math.floor(blockHeight / EVOLUTION_INTERVAL) + 1;
        }
        
        function calculateUnitsForGeneration(gen) {
            return 32 + (gen - 1) * 16; // Gen 1: 32, Gen 2: 48, Gen 3: 64, Gen 4: 80...
        }
        
        // --- Chart ---
        let lossChart = null;
        
        // ============================================
        // PEER DISCOVERY (No Firebase!)
        // ============================================
        
        // Method 1: URL parameter (share link to connect)
        // Method 2: localStorage (remember previous peers)
        // Method 3: Bootstrap node (hardcoded seed peer)
        
        let knownPeers = new Set();
        
        // ============================================
        // REPUTATION SYSTEM - Anti-Fraud Protection
        // ============================================
        
        let peerReputation = {}; // {peerId: {score, successCount, failCount, lastUpdate}}
        
        function loadReputation() {
            try {
                const saved = localStorage.getItem('p2p_reputation');
                if (saved) {
                    peerReputation = JSON.parse(saved);
                    console.log(`üìä Loaded reputation data: ${Object.keys(peerReputation).length} peers`);
                }
            } catch (e) {
                console.error("Failed to load reputation:", e);
            }
        }
        
        function saveReputation() {
            try {
                localStorage.setItem('p2p_reputation', JSON.stringify(peerReputation));
            } catch (e) {
                console.error("Failed to save reputation:", e);
            }
        }
        
        function getReputation(peerId) {
            if (!peerReputation[peerId]) {
                peerReputation[peerId] = {
                    score: 100, // Start with neutral score (0-200 range)
                    successCount: 0,
                    failCount: 0,
                    lastUpdate: Date.now()
                };
            }
            return peerReputation[peerId];
        }
        
        function updateReputation(peerId, success) {
            const rep = getReputation(peerId);
            
            if (success) {
                rep.successCount++;
                rep.score = Math.min(200, rep.score + 2); // +2 for honest behavior
                console.log(`‚úÖ ${peerId.substring(0, 8)} reputation increased: ${rep.score}`);
            } else {
                rep.failCount++;
                rep.score = Math.max(0, rep.score - 10); // -10 for fraud
                console.log(`‚ùå ${peerId.substring(0, 8)} reputation decreased: ${rep.score}`);
                
                // üö´ Blacklist if reputation too low
                if (rep.score < 20) {
                    addLog(`üö´ Peer ${peerId.substring(0, 8)} BLACKLISTED (Reputation: ${rep.score})`, "error");
                    
                    // Disconnect from peer
                    if (connections[peerId]) {
                        connections[peerId].close();
                        delete connections[peerId];
                    }
                    
                    // Remove from known peers
                    knownPeers.delete(peerId);
                }
            }
            
            rep.lastUpdate = Date.now();
            saveReputation();
        }
        
        function isBlacklisted(peerId) {
            const rep = getReputation(peerId);
            return rep.score < 20;
        }
        
        // Load previously connected peers from localStorage
        function loadKnownPeers() {
            try {
                const saved = localStorage.getItem('p2p_known_peers');
                if (saved) {
                    const peers = JSON.parse(saved);
                    // Filter out self when loading (myPeerId should be set by now)
                    peers.filter(p => p !== myPeerId).forEach(p => knownPeers.add(p));
                    console.log(`üìÇ Loaded ${peers.length} known peers from history`);
                }
            } catch(e) {
                console.error("Failed to load known peers:", e);
            }
        }
        
        // Save peer for future connections
        function rememberPeer(peerId) {
            // Don't remember self
            if (peerId === myPeerId) {
                console.warn(`‚ö†Ô∏è Attempted to remember self, skipping`);
                return;
            }
            
            knownPeers.add(peerId);
            try {
                // Filter out self before saving
                const peersToSave = [...knownPeers].filter(p => p !== myPeerId);
                localStorage.setItem('p2p_known_peers', JSON.stringify(peersToSave));
            } catch(e) {
                console.error("Failed to save peer:", e);
            }
        }
        
        // Get peer ID from URL parameter (?peer=xxx)
        function getPeerFromURL() {
            const params = new URLSearchParams(window.location.search);
            return params.get('peer');
        }
        
        // Generate shareable URL with your peer ID
        function generateShareURL() {
            if (!myPeerId) return '';
            const baseURL = window.location.origin + window.location.pathname;
            return `${baseURL}?peer=${myPeerId}`;
        }
        
        loadKnownPeers();
        loadReputation();
        
        // ============================================
        // PEERJS INITIALIZATION
        // ============================================
        
        function initP2P() {
            // üì± Initialize tab discovery (same browser)
            initTabDiscovery();
            
            // Try to load saved Peer ID from localStorage
            let savedPeerId = localStorage.getItem('p2p_peer_id');
            
            // Create peer with saved ID (or let PeerJS generate new one)
            const peerConfig = {
                config: {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:global.stun.twilio.com:3478' }
                    ]
                }
            };
            
            // If we have a saved ID, use it
            if (savedPeerId) {
                peer = new Peer(savedPeerId, peerConfig);
                console.log("üîÑ Restoring Peer ID:", savedPeerId);
            } else {
                peer = new Peer(peerConfig);
                console.log("üÜï Generating new Peer ID");
            }
            
            peer.on('open', (id) => {
                myPeerId = id;
                
                // Save Peer ID to localStorage for future sessions
                localStorage.setItem('p2p_peer_id', id);
                console.log("üÜî My Peer ID:", id, "(saved to localStorage)");
                
                document.getElementById('my-peer-id').innerText = id.substring(0, 8) + "...";
                addLog(`üÜî Peer ID: ${id.substring(0, 12)}... (ÏòÅÍµ¨ Ï†ÄÏû•Îê®)`, "success");
                
                // Enable share button
                document.getElementById('share-btn').disabled = false;
                
                // üì± Announce to other tabs in same browser
                console.log("üì¢ Initial announcement...");
                announceToOtherTabs();
                
                // Announce multiple times at start (more aggressive)
                setTimeout(() => {
                    console.log("üì¢ Second announcement...");
                    announceToOtherTabs();
                    scanForOtherTabs();
                }, 1000);
                
                setTimeout(() => {
                    console.log("üì¢ Third announcement...");
                    announceToOtherTabs();
                    scanForOtherTabs();
                }, 3000);
                
                // Keep announcing periodically (in case other tabs open later)
                setInterval(() => {
                    announceToOtherTabs();
                }, 2000); // Every 2 seconds (was 5)
                
                // Show shareable URL
                const shareURL = generateShareURL();
                addLog(`üìã Share URL: ${shareURL.substring(0, 50)}...`, "info");
                
                // Check URL for peer to connect to
                const urlPeer = getPeerFromURL();
                if (urlPeer && urlPeer !== id) {
                    addLog(`üîó Found peer in URL: ${urlPeer.substring(0, 12)}...`, "info");
                    connectToPeer(urlPeer);
                }
                
                // Reconnect to known peers
                if (knownPeers.size > 0) {
                    addLog(`üîÑ Reconnecting to ${knownPeers.size} known peers...`, "info");
                    knownPeers.forEach(peerId => {
                        if (peerId !== id) {
                            setTimeout(() => connectToPeer(peerId), 1000);
                        }
                    });
                }
                
                // Update total nodes (self + known peers)
                document.getElementById('total-nodes').innerText = knownPeers.size + 1;
            });
            
            peer.on('connection', (conn) => {
                setupConnection(conn);
                addLog(`üì• Incoming connection from ${conn.peer.substring(0, 8)}...`, "info");
            });
            
            peer.on('error', (err) => {
                console.error("PeerJS Error:", err.type, err.message);
                
                // Handle specific error types
                switch(err.type) {
                    case 'peer-unavailable':
                        // Peer is offline or doesn't exist - common, not critical
                        console.warn(`   Peer unavailable (offline or invalid ID)`);
                        break;
                    
                    case 'network':
                        // Network connectivity issue
                        addLog(`‚ö†Ô∏è Network connectivity issue`, "warn");
                        break;
                    
                    case 'server-error':
                        // PeerJS server issue
                        addLog(`‚ùå P2P Server Error: ${err.message}`, "error");
                        break;
                    
                    case 'socket-error':
                        // WebSocket connection issue
                        console.warn(`   Socket error: ${err.message}`);
                        break;
                    
                    case 'unavailable-id':
                        // Peer ID already taken
                        addLog(`‚ö†Ô∏è Peer ID conflict, regenerating...`, "warn");
                        // Could regenerate peer ID here if needed
                        break;
                    
                    default:
                        // Unknown error - log but don't spam user
                        console.error(`   Unhandled error type: ${err.type}`);
                        break;
                }
            });
        }
        
        // ============================================
        // PEER CONNECTION
        // ============================================
        
        function connectToPeer(peerId) {
            // Prevent self-connection
            if (peerId === myPeerId) {
                console.warn(`‚ö†Ô∏è Skipping self-connection: ${peerId.substring(0, 8)}`);
                return;
            }
            
            // Prevent duplicate connections
            if (connections[peerId]) {
                console.log(`‚ÑπÔ∏è Already connected to ${peerId.substring(0, 8)}`);
                return;
            }
            
            console.log(`üîó Attempting connection to ${peerId.substring(0, 8)}...`);
            
            try {
                const conn = peer.connect(peerId, { 
                    reliable: true,
                    serialization: 'json'
                });
                setupConnection(conn);
            } catch (e) {
                console.error(`‚ùå Failed to initiate connection to ${peerId.substring(0, 8)}:`, e.message);
            }
        }
        
        function setupConnection(conn) {
            connections[conn.peer] = conn;
            
            conn.on('open', () => {
                addLog(`‚úÖ Connected to ${conn.peer.substring(0, 8)}...`, "success");
                
                // Remember this peer for future connections
                rememberPeer(conn.peer);
                
                updatePeerList();
                
                // Send my current state
                sendToPeer(conn, {
                    type: 'hello',
                    loss: localBestLoss,
                    wallet: walletAddress,
                    myPeerId: myPeerId
                });
                
                // Request weights if I'm a new node (high loss = untrained)
                if (localBestLoss > 5.0 && model) {
                    addLog(`üì• Requesting trained model from ${conn.peer.substring(0, 8)}...`, "info");
                    sendToPeer(conn, {
                        type: 'request_weights'
                    });
                }
                
                // Request blockchain immediately and periodically
                // Immediate request
                sendToPeer(conn, {
                    type: 'request_chain'
                });
                
                // Request again after 2 seconds (in case first was missed)
                setTimeout(() => {
                    sendToPeer(conn, {
                        type: 'request_chain'
                    });
                }, 2000);
                
                // Request again after 5 seconds (ensure sync)
                setTimeout(() => {
                    sendToPeer(conn, {
                        type: 'request_chain'
                    });
                }, 5000);
            });
            
            conn.on('data', (data) => {
                handlePeerMessage(conn.peer, data);
            });
            
            conn.on('close', () => {
                delete connections[conn.peer];
                addLog(`‚ùå Disconnected from ${conn.peer.substring(0, 8)}...`, "warn");
                updatePeerList();
            });
            
            // üõ°Ô∏è Error handling for connection issues
            conn.on('error', (err) => {
                console.error(`‚ö†Ô∏è Connection error with ${conn.peer.substring(0, 8)}:`, err.type || err.message);
                
                // Clean up failed connection
                delete connections[conn.peer];
                updatePeerList();
                
                // Only show critical errors to user
                if (err.type === 'peer-unavailable') {
                    console.warn(`   Peer ${conn.peer.substring(0, 8)} is offline or unavailable`);
                } else if (err.type === 'network') {
                    addLog(`‚ö†Ô∏è Network error with peer ${conn.peer.substring(0, 8)}`, "warn");
                }
            });
        }
        
        function updatePeerList() {
            const connectedCount = Object.keys(connections).length;
            document.getElementById('connected-peers').innerText = connectedCount;
            
            const peerListEl = document.getElementById('peer-list');
            if (connectedCount === 0) {
                peerListEl.innerHTML = `
                    <p class="text-xs text-gray-500">No peers connected</p>
                    <p class="text-xs text-cyan-400 mt-2">üí° Tip: Open another tab - Auto-connects!</p>
                    <p class="text-xs text-blue-400 mt-1">Or click "COPY INVITE LINK" to share</p>
                `;
            } else {
                peerListEl.innerHTML = Object.keys(connections).map(peerId => 
                    `<div class="flex items-center gap-2 text-xs">
                        <div class="w-2 h-2 rounded-full bg-green-500 peer-node"></div>
                        <span class="font-mono">${peerId.substring(0, 12)}...</span>
                    </div>`
                ).join('');
            }
        }
        
        // ============================================
        // GOSSIP PROTOCOL & CONSENSUS
        // ============================================
        
        function broadcastToNetwork(message) {
            Object.values(connections).forEach(conn => {
                try {
                    conn.send(message);
                } catch(e) {
                    console.error("Failed to send to peer:", e);
                }
            });
        }
        
        function sendToPeer(conn, message) {
            try {
                conn.send(message);
            } catch(e) {
                console.error("Failed to send message:", e);
            }
        }
        
        function handlePeerMessage(peerId, data) {
            console.log("üì® Received from", peerId.substring(0, 8), ":", data.type);
            
            switch(data.type) {
                case 'hello':
                    addLog(`üëã ${peerId.substring(0, 8)}... says hello (Loss: ${data.loss?.toFixed(4)})`, "info");
                    
                    // Gossip: Share my known peers with new peer
                    if (data.myPeerId && knownPeers.size > 1) {
                        const peersToShare = [...knownPeers].filter(p => p !== peerId && p !== data.myPeerId).slice(0, 3);
                        if (peersToShare.length > 0) {
                            sendToPeer(connections[peerId], {
                                type: 'peer_list',
                                peers: peersToShare
                            });
                        }
                    }
                    break;
                    
                case 'peer_list':
                    // Discovered new peers through gossip
                    if (data.peers && Array.isArray(data.peers)) {
                        data.peers.forEach(newPeer => {
                            if (newPeer !== myPeerId && !connections[newPeer] && Object.keys(connections).length < MAX_PEERS) {
                                addLog(`üîç Discovered peer through gossip: ${newPeer.substring(0, 8)}...`, "info");
                                setTimeout(() => connectToPeer(newPeer), Math.random() * 2000);
                            }
                        });
                    }
                    break;
                    
                case 'weights_update':
                    handleWeightsUpdate(peerId, data);
                    break;
                    
                case 'gradients':
                    handleGradients(peerId, data);
                    break;
                    
                case 'block':
                    handleNewBlock(peerId, data);
                    break;
                    
                case 'request_weights':
                    sendMyWeights(peerId);
                    break;
                    
                case 'new_block':
                    handleNewBlock(peerId, data);
                    break;
                    
                case 'request_chain':
                    // Send full blockchain + global ledger to peer
                    sendToPeer(connections[peerId], {
                        type: 'blockchain',
                        chain: blockchain.chain,
                        ledger: globalLedger
                    });
                    break;
                    
                case 'blockchain':
                    // Received full chain from peer
                    if (data.chain && blockchain.replaceChain(data.chain)) {
                        addLog(`üîÑ Updated blockchain from ${peerId.substring(0, 8)}... (${data.chain.length} blocks)`, "success");
                        document.getElementById('blocks-received').innerText = blockchain.getBlockchainHeight();
                        
                        // Global LedgerÎèÑ ÎèôÍ∏∞Ìôî (ÌîºÏñ¥Í∞Ä Î≥¥ÎÇ∏ Ïû•Î∂Ä Ï†ïÎ≥¥)
                        if (data.ledger) {
                            Object.keys(data.ledger).forEach(address => {
                                if (!globalLedger[address] || globalLedger[address] < data.ledger[address]) {
                                    globalLedger[address] = data.ledger[address];
                                }
                            });
                            saveGlobalLedger();
                            addLog(`üìä Global ledger synchronized: ${Object.keys(globalLedger).length} accounts`, "info");
                        }
                    }
                    break;
            }
        }
        
        // ============================================
        // PROOF OF VALIDATION (PoV) - Verification System
        // ============================================
        
        // üéØ Efficient Verification using Spot-Checking (5-10% sampling)
        async function verifyLoss(receivedWeights, trainingData, reportedLoss, peerReputation = 100) {
            try {
                console.log("üßê Verifying block: Reported Loss =", reportedLoss);
                
                // Adaptive sampling based on peer reputation
                // High reputation ‚Üí less sampling needed
                // Low reputation ‚Üí more thorough checking
                let samplingRate = 0.1; // Default 10%
                if (peerReputation > 150) {
                    samplingRate = 0.05; // Trusted peer: 5%
                } else if (peerReputation < 80) {
                    samplingRate = 0.2;  // Suspicious peer: 20%
                }
                
                console.log(`üé≤ Sampling rate: ${(samplingRate * 100).toFixed(0)}% (Peer reputation: ${peerReputation})`);
                
                // 1. Create temporary verification model
                const tempModel = await createModel();
                
                // 2. Apply received weights to temporary model
                const tensors = receivedWeights.map(w => tf.tensor(w.data, w.shape));
                tempModel.setWeights(tensors);
                
                // 3. Process full data but sample for verification
                const { xs, ys } = processData(trainingData);
                
                if (!xs || !ys) {
                    console.warn("‚ö†Ô∏è Invalid training data for verification");
                    tensors.forEach(t => t.dispose());
                    tempModel.dispose();
                    return false;
                }
                
                // üéØ SPOT-CHECKING: Random sampling
                const totalSamples = xs.shape[0];
                const sampleSize = Math.max(5, Math.floor(totalSamples * samplingRate)); // At least 5 samples
                
                // Generate random indices
                const indices = [];
                const usedIndices = new Set();
                while (indices.length < sampleSize) {
                    const randomIdx = Math.floor(Math.random() * totalSamples);
                    if (!usedIndices.has(randomIdx)) {
                        indices.push(randomIdx);
                        usedIndices.add(randomIdx);
                    }
                }
                
                // Extract sampled data
                const xsSampled = tf.tidy(() => {
                    return tf.stack(indices.map(i => xs.slice([i, 0], [1, xs.shape[1]]).squeeze()));
                });
                
                const ysSampled = tf.tidy(() => {
                    return tf.stack(indices.map(i => ys.slice([i, 0], [1, ys.shape[1]]).squeeze()));
                });
                
                console.log(`üìä Spot-checking ${sampleSize}/${totalSamples} samples (${(samplingRate * 100).toFixed(0)}%)`);
                
                // 4. Evaluate on sampled data
                const evaluation = tempModel.evaluate(xsSampled, ysSampled);
                const actualLoss = await evaluation.data();
                const sampledLoss = actualLoss[0];
                
                // 5. Cleanup
                evaluation.dispose();
                xsSampled.dispose();
                ysSampled.dispose();
                xs.dispose();
                ys.dispose();
                tensors.forEach(t => t.dispose());
                tempModel.dispose();
                
                // 6. Verification: Sampled loss should be close to reported loss
                // Allow slightly more tolerance for sampled data
                const adjustedThreshold = VALIDATION_THRESHOLD * 1.5; // More lenient for sampling
                const diff = Math.abs(sampledLoss - reportedLoss);
                
                console.log(`üìä Sampled Loss: ${sampledLoss.toFixed(4)}, Reported: ${reportedLoss.toFixed(4)}, Diff: ${diff.toFixed(4)}`);
                
                if (diff < adjustedThreshold) {
                    console.log(`‚úÖ Validation PASSED (Spot-check: ${sampleSize} samples)`);
                    return true;
                } else {
                    console.warn(`‚ùå Validation FAILED: Difference ${diff.toFixed(4)} exceeds threshold ${adjustedThreshold.toFixed(4)}`);
                    return false;
                }
            } catch (e) {
                console.error("‚ùå Verification error:", e);
                return false;
            }
        }
        
        async function handleNewBlock(peerId, data) {
            const block = Object.assign(new Block(0, 0, "0", {}), data.block);
            const latestBlock = blockchain.getLatestBlock();
            
            // üö´ Check if peer is blacklisted
            if (isBlacklisted(peerId)) {
                addLog(`üö´ Block rejected: Peer ${peerId.substring(0, 8)} is blacklisted`, "error");
                return;
            }
            
            // üîñ Check model version compatibility (for weights verification)
            const blockVersion = block.modelVersion || 'unknown';
            if (blockVersion !== MODEL_VERSION && blockVersion !== 'unknown') {
                console.warn(`‚ö†Ô∏è Block #${block.index} has incompatible model version: ${blockVersion} vs ${MODEL_VERSION}`);
                addLog(`‚ö†Ô∏è Block #${block.index} skipped (incompatible model version)`, "warn");
                return;
            }
            
            if (block.index === latestBlock.index + 1) {
                const peerRep = getReputation(peerId);
                addLog(`üßê Verifying block #${block.index} from ${peerId.substring(0, 8)} (Rep: ${peerRep.score})...`, "info");
                
                // [Step 1] Basic blockchain validation (structural integrity)
                if (!blockchain.isValidNewBlock(block, latestBlock)) {
                    addLog(`‚ùå Block #${block.index} rejected: Invalid structure`, "error");
                    updateReputation(peerId, false); // Penalty for invalid structure
                    return;
                }
                
                // [Step 2] PoV validation (mathematical accuracy) - Check if peer is lying
                let weightsToVerify = block.weights;
                
                // üì¶ If block has IPFS CID, download weights from IPFS
                if (block.weightsCID && !weightsToVerify) {
                    try {
                        addLog(`üì• Downloading weights from IPFS: ${block.weightsCID.substring(0, 12)}...`, "info");
                        weightsToVerify = await downloadFromIPFS(block.weightsCID);
                        
                        if (weightsToVerify) {
                            addLog(`‚úÖ Weights downloaded from IPFS (Decentralized verification!)`, "success");
                        } else {
                            addLog(`‚ö†Ô∏è IPFS download failed, cannot verify block`, "error");
                            return;
                        }
                    } catch (e) {
                        console.error("IPFS download error:", e);
                        addLog(`‚ö†Ô∏è Block #${block.index} rejected: Cannot download weights from IPFS`, "error");
                        return;
                    }
                }
                
                // Verify if we have weights and training data
                if (weightsToVerify && block.trainingData) {
                    // üéØ Efficient verification with reputation-based sampling
                    const isLossValid = await verifyLoss(weightsToVerify, block.trainingData, block.loss, peerRep.score);
                    
                    if (!isLossValid) {
                        addLog(`‚ö†Ô∏è Block #${block.index} rejected: Loss verification FAILED (Fraud suspected!)`, "error");
                        updateReputation(peerId, false); // Heavy penalty for fraud
                        return;
                    }
                    
                    addLog(`‚úÖ PoV passed: Loss is mathematically correct`, "success");
                    updateReputation(peerId, true); // Reward honest behavior
                    
                    // üéÅ Award validator reward (reward for verification work)
                    addBalance(VALIDATION_REWARD);
                    updateGlobalLedger(walletAddress, VALIDATION_REWARD);
                    addLog(`üîç Validation reward: +${VALIDATION_REWARD} GEN (Verified!)`, "success");
                } else {
                    console.warn("‚ö†Ô∏è Block has no verification data (legacy block?)");
                }
                
                // [Step 3] All validations passed ‚Üí Add to blockchain
                blockchain.chain.push(block);
                blockchain.saveChain();
                
                // üí∞ Award miner reward (Update Global Ledger)
                if (block.reward && block.miner) {
                    updateGlobalLedger(block.miner, block.reward);
                    addLog(`üí∞ Miner reward ${block.reward} GEN credited to ${block.miner.substring(0, 8)}...`, "success");
                }
                
                // UI ÏóÖÎç∞Ïù¥Ìä∏
                document.getElementById('blocks-received').innerText = blockchain.getBlockchainHeight();
                addLog(`‚õìÔ∏è Block #${block.index} accepted (Loss: ${block.loss.toFixed(4)})`, "success");
                
                // üì° Îã§Î•∏ ÌîºÏñ¥ÏóêÍ≤å Ï†ÑÌåå (Gossip Protocol)
                Object.keys(connections).forEach(pid => {
                    if (pid !== peerId) {
                        sendToPeer(connections[pid], {
                            type: 'new_block',
                            block: block
                        });
                    }
                });
            } else if (block.index > latestBlock.index + 1) {
                // Missing blocks, request full chain
                addLog(`‚ö†Ô∏è Missing blocks detected, requesting full chain...`, "warn");
                sendToPeer(connections[peerId], {
                    type: 'request_chain'
                });
            }
        }
        
        async function handleWeightsUpdate(peerId, data) {
            const receivedLoss = data.loss;
            const receivedWeights = data.weights;
            const receivedVersion = data.modelVersion || 'unknown';
            
            addLog(`üß† Weights received from ${peerId.substring(0, 8)}... (Loss: ${receivedLoss.toFixed(4)})`, "info");
            
            // Check version compatibility
            if (receivedVersion !== MODEL_VERSION && receivedVersion !== 'unknown') {
                console.warn(`‚ö†Ô∏è Received weights version mismatch: ${receivedVersion} vs ${MODEL_VERSION}`);
                addLog(`‚ö†Ô∏è Rejected weights (incompatible version)`, "warn");
                return;
            }
            
            // Consensus: Only accept if better than local
            if (receivedLoss < localBestLoss && receivedWeights) {
                console.log(`‚úÖ Accepting better weights (${receivedLoss.toFixed(4)} < ${localBestLoss.toFixed(4)})`);
                
                try {
                    // Apply weights to model
                    if (model) {
                        const modelWeights = model.getWeights();
                        
                        // Verify weight count matches
                        if (receivedWeights.length !== modelWeights.length) {
                            throw new Error(`Weight count mismatch: received=${receivedWeights.length}, model=${modelWeights.length}`);
                        }
                        
                        const tensors = receivedWeights.map(w => tf.tensor(w.data, w.shape));
                        model.setWeights(tensors);
                        tensors.forEach(t => t.dispose());
                        
                        localBestLoss = receivedLoss;
                        document.getElementById('local-loss').innerText = localBestLoss.toFixed(4);
                        
                        // Save to localStorage
                        saveWeightsToStorage(receivedWeights, receivedLoss);
                        
                        // ü§ù Update collaboration stats
                        collaborationStats.weightsReceived++;
                        saveCollaborationStats();
                        updateCollaborationUI();
                        
                        addLog(`‚úÖ Applied better weights from network (Total received: ${collaborationStats.weightsReceived})`, "success");
                        
                        // Gossip to other peers
                        broadcastToNetwork({
                            type: 'weights_update',
                            loss: receivedLoss,
                            weights: receivedWeights,
                            modelVersion: MODEL_VERSION,
                            generation: currentGeneration,
                            origin: peerId
                        });
                    }
                } catch(e) {
                    console.error("Failed to apply weights:", e);
                }
            } else {
                console.log(`‚ùå Rejecting weights (${receivedLoss.toFixed(4)} >= ${localBestLoss.toFixed(4)})`);
            }
            
            // Update global best
            if (receivedLoss < networkState.bestLoss) {
                networkState.bestLoss = receivedLoss;
                document.getElementById('global-loss').innerText = receivedLoss.toFixed(4);
            }
        }
        
        function sendMyWeights(peerId) {
            if (!model) return;
            
            addLog(`üì§ Sharing my model (Loss: ${localBestLoss.toFixed(4)}) with ${peerId.substring(0, 8)}...`, "info");
            
            const weights = model.getWeights().map(w => ({
                data: Array.from(w.dataSync()),
                shape: w.shape
            }));
            
            const conn = connections[peerId];
            if (conn) {
                sendToPeer(conn, {
                    type: 'weights_update',
                    loss: localBestLoss,
                    weights: weights,
                    modelVersion: MODEL_VERSION,
                    generation: currentGeneration
                });
            }
        }
        
        // ============================================
        // TENSORFLOW.JS MODEL
        // ============================================
        
        // üî• Advanced LSTM + Attention Hybrid (Stable & Modern)
        async function createModel(generation = 1) {
            const units = calculateUnitsForGeneration(generation);
            const embeddingDim = Math.min(32 + (generation - 1) * 8, 128);
            
            // Use Functional API for Attention mechanism
            const input = tf.input({shape: [SEQUENCE_LENGTH]});
            
            // Embedding layer
            let embedded = tf.layers.embedding({
                inputDim: vocab.length,
                outputDim: embeddingDim,
                inputLength: SEQUENCE_LENGTH,
                name: 'word_embedding'
            }).apply(input);
            
            // üß† Bidirectional LSTM (captures context from both directions)
            const lstm1 = tf.layers.bidirectional({
                layer: tf.layers.lstm({
                    units: units,
                    returnSequences: true,
                    kernelInitializer: 'glorotUniform',
                    recurrentInitializer: 'glorotUniform'
                }),
                name: 'bidirectional_lstm'
            }).apply(embedded);
            
            // üéØ Self-Attention Mechanism (Simplified)
            // Use global max pooling and global average pooling
            const maxPooled = tf.layers.globalMaxPooling1d({
                name: 'global_max_pool'
            }).apply(lstm1);
            
            const avgPooled = tf.layers.globalAveragePooling1d({
                name: 'global_avg_pool'
            }).apply(lstm1);
            
            // Concatenate both pooling outputs (captures both prominent and average features)
            const concatenated = tf.layers.concatenate({
                name: 'concat_pools'
            }).apply([maxPooled, avgPooled]);
            
            // üåü Feed-Forward Network
            let dense1 = tf.layers.dense({
                units: units * 2,
                activation: 'relu',
                kernelInitializer: 'glorotUniform',
                name: 'ff_layer1'
            }).apply(concatenated);
            
            // Dropout for regularization
            dense1 = tf.layers.dropout({
                rate: 0.2,
                name: 'dropout1'
            }).apply(dense1);
            
            let dense2 = tf.layers.dense({
                units: units,
                activation: 'relu',
                kernelInitializer: 'glorotUniform',
                name: 'ff_layer2'
            }).apply(dense1);
            
            dense2 = tf.layers.dropout({
                rate: 0.1,
                name: 'dropout2'
            }).apply(dense2);
            
            // Output layer
            const output = tf.layers.dense({
                units: vocab.length,
                activation: 'softmax',
                kernelInitializer: 'glorotUniform',
                name: 'output'
            }).apply(dense2);
            
            const model = tf.model({inputs: input, outputs: output});
            
            model.compile({
                optimizer: tf.train.adam(0.001),
                loss: 'categoricalCrossentropy',
                metrics: ['accuracy']
            });
            
            const params = model.countParams();
            document.getElementById('model-params').innerText = (params / 1000).toFixed(1) + 'K';
            
            console.log(`üß† Gen ${generation} Model: BiLSTM + Attention, ${embeddingDim}d embed, ${params} params`);
            return model;
        }

        // üß¨ Knowledge Transfer: Transfer knowledge from previous generation to new
        async function upgradeBrain(oldModel, newGeneration) {
            console.log(`üß¨ Evolving to Generation ${newGeneration}...`);
            
            const newModel = await createModel(newGeneration);
            
            if (!oldModel) {
                console.log("üÜï First generation, no knowledge to transfer");
                return newModel;
            }
            
            try {
                const oldWeights = oldModel.getWeights();
                const newWeights = newModel.getWeights();
                const transferredWeights = [];
                
                // Weight transfer: Copy only overlapping parts (preserve knowledge)
                for (let i = 0; i < newWeights.length; i++) {
                    if (i >= oldWeights.length) {
                        // ÏÉàÎ°úÏö¥ Î†àÏù¥Ïñ¥Îäî Í∑∏ÎåÄÎ°ú Ïú†ÏßÄ
                        transferredWeights.push(newWeights[i]);
                        console.log(`  üÜï Layer ${i}: New layer (${newWeights[i].shape})`);
                        continue;
                    }
                    
                    const oldShape = oldWeights[i].shape;
                    const newShape = newWeights[i].shape;
                    
                    // ÌÅ¨Í∏∞Í∞Ä Í∞ôÏúºÎ©¥ Í∑∏ÎåÄÎ°ú Î≥µÏÇ¨
                    if (JSON.stringify(oldShape) === JSON.stringify(newShape)) {
                        transferredWeights.push(tf.clone(oldWeights[i]));
                        console.log(`  ‚úÖ Layer ${i}: Transferred (${oldShape})`);
                    } 
                    // ÌÅ¨Í∏∞Í∞Ä Îã§Î•¥Î©¥ Î∂ÄÎ∂Ñ Î≥µÏÇ¨ (ÌôïÏû•Îêú Î∂ÄÎ∂ÑÏùÄ ÎûúÎç§ Ï¥àÍ∏∞Ìôî)
                    else if (oldShape.length === newShape.length) {
                        const oldData = await oldWeights[i].array();
                        const newData = await newWeights[i].array();
                        
                        // Îã§Ï∞®Ïõê Î∞∞Ïó¥ Ï≤òÎ¶¨
                        const mergedData = JSON.parse(JSON.stringify(newData)); // Deep copy
                        
                        // Í≤πÏπòÎäî ÏòÅÏó≠Îßå Î≥µÏÇ¨ (Ïû¨Í∑ÄÏ†ÅÏúºÎ°ú)
                        function copyRecursive(target, source, depth = 0) {
                            if (depth >= oldShape.length) return;
                            
                            const minLength = Math.min(target.length, source.length);
                            for (let i = 0; i < minLength; i++) {
                                if (Array.isArray(target[i]) && Array.isArray(source[i])) {
                                    copyRecursive(target[i], source[i], depth + 1);
                                } else {
                                    target[i] = source[i];
                                }
                            }
                        }
                        
                        copyRecursive(mergedData, oldData);
                        
                        const updatedWeight = tf.tensor(mergedData, newShape);
                        transferredWeights.push(updatedWeight);
                        console.log(`  ‚ö° Layer ${i}: Partial transfer (${oldShape} ‚Üí ${newShape})`);
                    } else {
                        // For incompatible shapes, use new weights as is
                        transferredWeights.push(tf.clone(newWeights[i]));
                        console.log(`  ‚è≠Ô∏è  Layer ${i}: Kept new (incompatible: ${oldShape} vs ${newShape})`);
                    }
                }
                
                // ÏÉà Í∞ÄÏ§ëÏπò ÏÑ§Ï†ï
                newModel.setWeights(transferredWeights);
                
                // Î©îÎ™®Î¶¨ Ï†ïÎ¶¨
                transferredWeights.forEach(w => {
                    if (w !== newWeights[w]) {
                        // Ïö∞Î¶¨Í∞Ä ÎßåÎì† ÌÖêÏÑúÎßå dispose (Î™®Îç∏ ÎÇ¥Î∂Ä Í≤ÉÏùÄ Î™®Îç∏Ïù¥ Í¥ÄÎ¶¨)
                    }
                });
                
                console.log("‚úÖ Knowledge transfer complete!");
                
            } catch (e) {
                console.error("‚ö†Ô∏è Knowledge transfer failed:", e);
                // Ïã§Ìå® Ïãú ÏÉà Î™®Îç∏ Í∑∏ÎåÄÎ°ú Î∞òÌôò
            }
            
            return newModel;
        }

        // --- Wikipedia Data Foraging - UNLIMITED KNOWLEDGE! ---
        let cachedWikiText = null;
        let lastFetchTime = 0;
        const FETCH_INTERVAL = 5000; // 5Ï¥àÎßàÎã§ ÏÉàÎ°úÏö¥ Îç∞Ïù¥ÌÑ∞ (Îπ†Î•∏ Îã§ÏñëÏÑ±)
        
        // ============================================
        // AUTONOMOUS DATA FORAGING - Multi-Source Intelligence
        // ============================================
        
        const DATA_SOURCES = {
            WIKIPEDIA: {
                name: 'Wikipedia',
                icon: 'üìö',
                priority: 1.0,
                successRate: 1.0,
                lastLoss: 9.9,
                fetcher: fetchWikipediaData
            },
            HACKERNEWS: {
                name: 'Hacker News',
                icon: 'üî∂',
                priority: 1.0,
                successRate: 1.0,
                lastLoss: 9.9,
                fetcher: fetchHackerNewsData
            },
            REDDIT: {
                name: 'Reddit',
                icon: 'ü§ñ',
                priority: 1.0,
                successRate: 1.0,
                lastLoss: 9.9,
                fetcher: fetchRedditData
            },
            ARXIV: {
                name: 'arXiv Papers',
                icon: 'üî¨',
                priority: 1.0,
                successRate: 1.0,
                lastLoss: 9.9,
                fetcher: fetchArxivData
            }
        };
        
        let currentDataSource = 'WIKIPEDIA';
        let dataSourceStats = {...DATA_SOURCES};
        
        // üéØ Autonomous Source Selection based on Loss
        function selectOptimalDataSource() {
            // If current loss is high (> 2.0), switch to better performing source
            if (localBestLoss > 2.0) {
                // Sort sources by performance (low loss = high priority)
                const sortedSources = Object.entries(dataSourceStats)
                    .sort((a, b) => {
                        // Score = successRate / lastLoss (higher is better)
                        const scoreA = a[1].successRate / (a[1].lastLoss + 0.1);
                        const scoreB = b[1].successRate / (b[1].lastLoss + 0.1);
                        return scoreB - scoreA;
                    });
                
                const bestSource = sortedSources[0][0];
                
                if (bestSource !== currentDataSource) {
                    console.log(`üîÑ Switching data source: ${currentDataSource} -> ${bestSource}`);
                    console.log(`   Reason: High loss detected (${localBestLoss.toFixed(3)})`);
                    addLog(`üîÑ Switching to ${dataSourceStats[bestSource].icon} ${dataSourceStats[bestSource].name}`, "info");
                    currentDataSource = bestSource;
                }
            }
            
            // Random exploration (10% chance) to discover new good sources
            if (Math.random() < 0.1) {
                const sources = Object.keys(dataSourceStats);
                currentDataSource = sources[Math.floor(Math.random() * sources.length)];
                console.log(`üé≤ Random exploration: ${currentDataSource}`);
            }
            
            return currentDataSource;
        }
        
        // Update source performance based on training results
        function updateSourcePerformance(source, loss, success) {
            if (dataSourceStats[source]) {
                dataSourceStats[source].lastLoss = loss;
                dataSourceStats[source].successRate = 
                    dataSourceStats[source].successRate * 0.9 + (success ? 0.1 : 0);
            }
        }
        
        // üìö Wikipedia API
        async function fetchWikipediaData() {
            try {
                const randomUrl = 'https://en.wikipedia.org/api/rest_v1/page/random/summary';
                const response = await fetch(randomUrl);
                if (!response.ok) throw new Error("Wikipedia fetch failed");
                
                const data = await response.json();
                const text = data.extract || data.description || "";
                const title = data.title || "Unknown";
                
                if (text.length > 100) {
                    displayLearningContent('üìö', 'Wikipedia', title, text);
                    return {text, title, source: 'WIKIPEDIA'};
                }
            } catch (e) {
                console.warn("Wikipedia error:", e);
            }
            return null;
        }
        
        // üî∂ Hacker News API (Top Stories)
        async function fetchHackerNewsData() {
            try {
                const topStoriesUrl = 'https://hacker-news.firebaseio.com/v0/topstories.json';
                const storiesRes = await fetch(topStoriesUrl);
                const storyIds = await storiesRes.json();
                
                // Get random story from top 30
                const randomId = storyIds[Math.floor(Math.random() * Math.min(30, storyIds.length))];
                const storyUrl = `https://hacker-news.firebaseio.com/v0/item/${randomId}.json`;
                const storyRes = await fetch(storyUrl);
                const story = await storyRes.json();
                
                const title = story.title || "Unknown";
                const text = story.text || story.title || "";
                
                if (text.length > 50) {
                    displayLearningContent('üî∂', 'Hacker News', title, text);
                    return {text, title, source: 'HACKERNEWS'};
                }
            } catch (e) {
                console.warn("Hacker News error:", e);
            }
            return null;
        }
        
        // ü§ñ Reddit RSS Feed (r/science, r/technology, r/philosophy)
        async function fetchRedditData() {
            try {
                const subreddits = ['science', 'technology', 'philosophy', 'MachineLearning', 'programming'];
                const sub = subreddits[Math.floor(Math.random() * subreddits.length)];
                
                // Reddit JSON API (no auth needed for public posts)
                const url = `https://www.reddit.com/r/${sub}/hot.json?limit=10`;
                const response = await fetch(url, {
                    headers: {'User-Agent': 'GenesisAI/1.0'}
                });
                
                if (!response.ok) throw new Error("Reddit fetch failed");
                
                const data = await response.json();
                const posts = data.data.children;
                
                if (posts && posts.length > 0) {
                    const randomPost = posts[Math.floor(Math.random() * posts.length)].data;
                    const title = randomPost.title || "Unknown";
                    const text = (randomPost.selftext || randomPost.title || "").substring(0, 1000);
                    
                    if (text.length > 50) {
                        displayLearningContent('ü§ñ', `Reddit r/${sub}`, title, text);
                        return {text, title, source: 'REDDIT'};
                    }
                }
            } catch (e) {
                console.warn("Reddit error:", e);
            }
            return null;
        }
        
        // üî¨ arXiv API (Scientific Papers)
        async function fetchArxivData() {
            try {
                // Random search query from AI/CS topics
                const topics = ['machine+learning', 'neural+networks', 'deep+learning', 'artificial+intelligence', 'computer+science'];
                const topic = topics[Math.floor(Math.random() * topics.length)];
                
                const url = `https://export.arxiv.org/api/query?search_query=all:${topic}&start=0&max_results=10&sortBy=submittedDate&sortOrder=descending`;
                const response = await fetch(url);
                const xmlText = await response.text();
                
                // Simple XML parsing for entry content
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(xmlText, "text/xml");
                const entries = xmlDoc.getElementsByTagName("entry");
                
                if (entries.length > 0) {
                    const randomEntry = entries[Math.floor(Math.random() * entries.length)];
                    const title = randomEntry.getElementsByTagName("title")[0]?.textContent || "Unknown";
                    const summary = randomEntry.getElementsByTagName("summary")[0]?.textContent || "";
                    const text = summary.trim();
                    
                    if (text.length > 100) {
                        displayLearningContent('üî¨', 'arXiv', title, text);
                        return {text, title, source: 'ARXIV'};
                    }
                }
            } catch (e) {
                console.warn("arXiv error:", e);
            }
            return null;
        }
        
        // Display what we're learning
        function displayLearningContent(icon, source, title, text) {
            const preview = text.substring(0, 200) + (text.length > 200 ? "..." : "");
            document.getElementById('learning-preview').innerHTML = 
                `<div class="text-yellow-400 font-bold mb-1">${icon} ${source}: ${title}</div>` +
                `<div class="text-gray-300 text-sm">${preview}</div>`;
            
            addLog(`${icon} Learning from ${source}`, "info");
            console.log(`üìñ Source: ${source} | Topic: ${title} (${text.length} chars)`);
        }
        
        // üß† Intelligent Data Fetcher with Auto-Selection
        async function fetchIntelligentData() {
            // Select optimal source based on performance
            const sourceKey = selectOptimalDataSource();
            const source = dataSourceStats[sourceKey];
            
            try {
                const result = await source.fetcher();
                
                if (result && result.text) {
                    updateSourcePerformance(sourceKey, localBestLoss, true);
                    return result.text;
                } else {
                    updateSourcePerformance(sourceKey, 9.9, false);
                }
            } catch (e) {
                console.warn(`${source.name} failed:`, e);
                updateSourcePerformance(sourceKey, 9.9, false);
            }
            
            // Fallback: High-quality seed texts
            const fallbacks = [
                "Artificial intelligence and machine learning are transforming our world through neural networks and distributed computing systems.",
                "The universe contains billions of galaxies, each with billions of stars and potentially countless planets.",
                "Philosophy explores fundamental questions about existence, knowledge, values, reason, mind, and language.",
                "Mathematics is the abstract study of topics such as quantity, structure, space, and change.",
                "Evolution by natural selection is the process by which species adapt to their environment over generations."
            ];
            const fallback = fallbacks[Math.floor(Math.random() * fallbacks.length)];
            document.getElementById('learning-preview').innerHTML = 
                `<div class="text-gray-500">Fallback training data</div>`;
            return fallback;
        }
        
        async function generateTrainingData() {
            const now = Date.now();
            
            // üîÑ Fetch from intelligent multi-source system
            if (!cachedWikiText || (now - lastFetchTime > FETCH_INTERVAL)) {
                cachedWikiText = await fetchIntelligentData();
                lastFetchTime = now;
            }
            
            return cachedWikiText;
        }
        
        function processData(text) {
            const xs = [];
            const ys = [];
            
            text = text.toLowerCase().replace(/[^a-z .]/g, '');
            
            if (text.length <= SEQUENCE_LENGTH) return { xs: null, ys: null };
            
            for (let i = 0; i < text.length - SEQUENCE_LENGTH; i++) {
                const seq = text.slice(i, i + SEQUENCE_LENGTH);
                const target = text[i + SEQUENCE_LENGTH];
                
                xs.push(seq.split('').map(c => charToIndex[c] || 0));
                
                const y = new Array(vocab.length).fill(0);
                y[charToIndex[target] || 0] = 1;
                ys.push(y);
            }
            
            if (xs.length === 0) return { xs: null, ys: null };
            
            return {
                xs: tf.tensor2d(xs, [xs.length, SEQUENCE_LENGTH]),
                ys: tf.tensor2d(ys, [ys.length, vocab.length])
            };
        }

        async function trainStep() {
            if (!isMining || !model) return;
            
            try {
                const trainingText = await generateTrainingData();
                const { xs, ys } = processData(trainingText);
                
                if (!xs || !ys) {
                    setTimeout(trainStep, 1000);
                    return;
                }
                
            const history = await model.fit(xs, ys, {
                epochs: 1,
                    batchSize: 32,
                    shuffle: true,
                    verbose: 0
            });
            
            const loss = history.history.loss[0];
            
                xs.dispose();
                ys.dispose();
                
                // üìä Update data source performance based on loss
                updateSourcePerformance(currentDataSource, loss, loss < 5.0);
                
                // üìä [System 1] Contribution reward: Pay for computation work (Computing power reward)
                addBalance(REWARD_PER_EPOCH);
                epochCount++;
                document.getElementById('epochs').innerText = epochCount;
                
                // ü§ù Federated Learning: Share gradients periodically
                if (epochCount % GRADIENT_AGGREGATION_INTERVAL === 0 && Object.keys(connections).length > 0) {
                    shareGradients();
                }
                
                // Update chart (keep only last 10 data points)
                lossHistory.push(loss);
                if (lossHistory.length > 10) lossHistory.shift();
                updateChart();
                updateDataSourcesUI(); // Update data source performance display
                
                // üèÜ [System 2] Performance reward: Create block and get bonus when intelligence improves
                if (loss < localBestLoss) {
                    localBestLoss = loss;
                    document.getElementById('local-loss').innerText = loss.toFixed(4);
                    
                    addLog(`üéâ New best local loss: ${loss.toFixed(4)}`, "success");
                    
                    // Extract weights for verification
                    const weights = model.getWeights().map(w => ({
                        data: Array.from(w.dataSync()),
                        shape: w.shape
                    }));
                    
                    // Calculate weights hash
                    const weightsHash = hashWeights(weights);
                    
                    // üì¶ Upload weights to IPFS (if available)
                    let weightsCID = null;
                    try {
                        weightsCID = await uploadToIPFS(weights);
                        if (weightsCID) {
                            addLog(`üì¶ Weights uploaded to IPFS: ${weightsCID.substring(0, 12)}...`, "info");
                        }
                    } catch (e) {
                        console.warn("IPFS upload failed, will include weights in block:", e);
                    }
                    
                    // üîê Add block to blockchain with IPFS CID (or full weights as fallback)
                    const newBlock = blockchain.addBlock({
                        miner: walletAddress,
                        loss: loss,
                        weightsHash: weightsHash,
                        peerId: myPeerId,
                        weightsCID: weightsCID,        // üì¶ IPFS CID (preferred - saves bandwidth)
                        weights: weightsCID ? null : weights, // ‚úÖ Fallback: full weights if IPFS unavailable
                        trainingData: trainingText,    // ‚úÖ Include training data evidence
                        reward: BLOCK_WIN_REWARD,      // üéÅ Performance reward (5.0 GEN)
                        modelVersion: MODEL_VERSION,   // üîñ Model architecture version
                        generation: currentGeneration  // üß¨ Evolution generation
                    });
                    
                    if (newBlock) {
                        document.getElementById('blocks-received').innerText = blockchain.getBlockchainHeight();
                        
                        // Award BLOCK WIN reward (not epoch reward)
                        addBalance(BLOCK_WIN_REWARD);
                        updateGlobalLedger(walletAddress, BLOCK_WIN_REWARD);
                        
                        // ü§ù Update collaboration stats
                        collaborationStats.blocksContributed++;
                        saveCollaborationStats();
                        updateCollaborationUI();
                        
                        addLog(`‚õèÔ∏è Block #${newBlock.index} mined! Intelligence boost bonus üí∞ +${BLOCK_WIN_REWARD} GEN`, "success");
                    }
                    
                    broadcastToNetwork({
                        type: 'weights_update',
                        loss: loss,
                        weights: weights,
                        modelVersion: MODEL_VERSION,
                        generation: currentGeneration,
                        origin: myPeerId
                    });
                    
                    // Save to localStorage
                    saveWeightsToStorage(weights, loss);
                    
                    // Update global best
                    if (loss < networkState.bestLoss) {
                        networkState.bestLoss = loss;
                        document.getElementById('global-loss').innerText = loss.toFixed(4);
                    }
                }
                
                // üß¨ Check for Evolution (after each block creation)
                const blockHeight = blockchain.getBlockchainHeight();
                const targetGeneration = getGenerationFromBlockHeight(blockHeight);
                
                // Update network generation display
                const networkGen = targetGeneration;
                const genText = ['1st', '2nd', '3rd'];
                const netGenText = networkGen <= 3 ? genText[networkGen - 1] : `${networkGen}th`;
                document.getElementById('network-gen-value').innerText = `${netGenText} Gen`;
                
                // Show sync warning if generations don't match
                const syncWarning = document.getElementById('sync-warning');
                if (currentGeneration !== networkGen) {
                    syncWarning.classList.remove('hidden');
                } else {
                    syncWarning.classList.add('hidden');
                }
                
                // Check if local generation is behind
                if (currentGeneration < targetGeneration - 1) {
                    // More than 1 generation behind - recommend restart
                    addLog(`‚ö†Ô∏è You are ${targetGeneration - currentGeneration} generation(s) behind! Stop and restart mining.`, "warn");
                }
                
                if (targetGeneration > currentGeneration) {
                    addLog(`üß¨ EVOLUTION TRIGGERED! Gen ${currentGeneration} ‚Üí Gen ${targetGeneration}`, "success");
                    addLog(`‚è∏Ô∏è Pausing mining for evolution...`, "info");
                    
                    const oldLoss = localBestLoss;
                    const oldModel = model;
                    model = await upgradeBrain(oldModel, targetGeneration);
                    
                    if (oldModel) {
                        oldModel.dispose();
                    }
                    
                    currentGeneration = targetGeneration;
                    
                    // Update UI
                    const genText = ['1st', '2nd', '3rd'];
                    const suffix = currentGeneration <= 3 ? genText[currentGeneration - 1] : `${currentGeneration}th`;
                    const units = calculateUnitsForGeneration(currentGeneration);
                    document.getElementById('brain-generation').innerText = `${suffix} Gen`;
                    document.getElementById('brain-generation').title = `${units} units - More powerful than Gen ${currentGeneration - 1}`;
                    
                    addLog(`‚ú® Brain upgraded to ${suffix} Generation! (${units} units)`, "success");
                    
                    // üî• Intensive training after evolution (stabilize new parameters)
                    addLog(`üéØ Post-evolution training (adapting new parameters)...`, "info");
                    
                    const evolutionTrainingRounds = 5; // Train 5 times intensively
                    for (let round = 0; round < evolutionTrainingRounds; round++) {
                        try {
                            const trainingText = await generateTrainingData();
                            const { xs, ys } = processData(trainingText);
                            
                            if (xs && ys) {
                                const history = await model.fit(xs, ys, {
                                    epochs: 3, // 3 epochs per round
                                    batchSize: 32,
                                    shuffle: true,
                                    verbose: 0
                                });
                                
                                const newLoss = history.history.loss[history.history.loss.length - 1];
                                console.log(`  üîÑ Evolution training ${round + 1}/${evolutionTrainingRounds}: Loss ${newLoss.toFixed(4)}`);
                                
                                if (newLoss < localBestLoss) {
                                    localBestLoss = newLoss;
                                    document.getElementById('local-loss').innerText = localBestLoss.toFixed(4);
                                }
                                
                                xs.dispose();
                                ys.dispose();
                            }
                        } catch (e) {
                            console.error("Evolution training error:", e);
                        }
                    }
                    
                    const improvement = oldLoss - localBestLoss;
                    if (improvement > 0) {
                        addLog(`‚úÖ Evolution complete! Intelligence improved by ${(improvement * 100).toFixed(1)}%`, "success");
                    } else {
                        addLog(`‚úÖ Evolution complete! New generation is adapting...`, "success");
                    }
                    
                    addLog(`‚ñ∂Ô∏è Resuming normal mining...`, "info");
                }
                
                // Update evolution progress UI
                const blocksInGen = blockHeight % EVOLUTION_INTERVAL;
                document.getElementById('evolution-progress').innerText = `${blocksInGen}/${EVOLUTION_INTERVAL} blocks`;
                
                setTimeout(trainStep, 0);
                
            } catch(e) {
                console.error("Training error:", e);
                addLog(`‚ùå Training error: ${e.message}`, "error");
                await new Promise(r => setTimeout(r, 1000));
                if (isMining) setTimeout(trainStep, 0);
            }
        }
        
        // ============================================
        // LOCAL STORAGE PERSISTENCE
        // ============================================
        
        function saveWeightsToStorage(weights, loss) {
            try {
                const data = JSON.stringify({
                    weights: weights,
                    loss: loss,
                    timestamp: Date.now(),
                    modelVersion: MODEL_VERSION,
                    generation: currentGeneration
                });
                
                // Check size
                const sizeKB = (data.length / 1024).toFixed(2);
                console.log(`üíæ Attempting to save weights: ${sizeKB} KB`);
                
                localStorage.setItem('p2p_best_weights', data);
                console.log(`‚úÖ Weights saved successfully`);
            } catch(e) {
                if (e.name === 'QuotaExceededError') {
                    console.error("‚ùå localStorage full! Attempting cleanup...");
                    
                    // Clean up old/unnecessary data
                    cleanupLocalStorage();
                    
                    // Try again after cleanup
                    try {
                        localStorage.setItem('p2p_best_weights', JSON.stringify({
                            weights: weights,
                            loss: loss,
                            timestamp: Date.now(),
                            modelVersion: MODEL_VERSION,
                            generation: currentGeneration
                        }));
                        console.log("‚úÖ Weights saved after cleanup");
                        addLog("‚ö†Ô∏è localStorage was full, cleaned up old data", "warn");
                    } catch(e2) {
                        console.error("‚ùå Still failed after cleanup:", e2);
                        addLog("‚ùå Cannot save weights: Storage full!", "error");
                    }
            } else {
                    console.error("Failed to save weights:", e);
                }
            }
        }
        
        function cleanupLocalStorage() {
            console.log("üßπ Cleaning up localStorage...");
            
            // Remove old/unnecessary items
            const itemsToCheck = [
                'p2p_blockchain', // Can be re-synced from network
                'genesis_active_tabs', // Can be regenerated
                'p2p_collab_stats' // Not critical
            ];
            
            itemsToCheck.forEach(key => {
                const item = localStorage.getItem(key);
                if (item) {
                    const sizeKB = (item.length / 1024).toFixed(2);
                    console.log(`  - ${key}: ${sizeKB} KB`);
                }
            });
            
            // Remove blockchain (can re-sync from peers)
            localStorage.removeItem('p2p_blockchain');
            console.log("  ‚úÖ Removed blockchain (will re-sync from network)");
            
            // Clear active tabs list
            localStorage.removeItem('genesis_active_tabs');
            console.log("  ‚úÖ Cleared active tabs list");
        }
        
        function loadWeightsFromStorage() {
            try {
                const saved = localStorage.getItem('p2p_best_weights');
                if (saved) {
                    const data = JSON.parse(saved);
                    
                    // Check model version compatibility
                    if (data.modelVersion !== MODEL_VERSION) {
                        console.warn(`‚ö†Ô∏è Saved weights version mismatch: ${data.modelVersion || 'unknown'} vs ${MODEL_VERSION}`);
                        console.warn("   Clearing incompatible weights...");
                        localStorage.removeItem('p2p_best_weights');
                        addLog("‚ö†Ô∏è Previous model weights incompatible (cleared)", "warn");
                        return null;
                    }
                    
                    // Check generation compatibility
                    if (data.generation !== currentGeneration) {
                        console.warn(`‚ö†Ô∏è Saved weights generation mismatch: Gen ${data.generation} vs Gen ${currentGeneration}`);
                        console.warn("   Clearing incompatible weights...");
                        localStorage.removeItem('p2p_best_weights');
                        return null;
                    }
                    
                    console.log(`üìÇ Found saved weights (Loss: ${data.loss.toFixed(4)}, Version: ${data.modelVersion}, Gen: ${data.generation})`);
                    return data;
                }
            } catch(e) {
                console.error("Failed to load weights:", e);
            }
            return null;
        }
        
        // ============================================
        // UI & VISUALIZATION
        // ============================================
        
        function addLog(message, type = "info") {
            const feed = document.getElementById('activity-feed');
            const p = document.createElement('p');
            
            const colors = {
                info: 'text-blue-400',
                success: 'text-green-400',
                warn: 'text-yellow-400',
                error: 'text-red-400'
            };
            
            p.className = colors[type] || 'text-gray-400';
            p.innerHTML = `<span class="text-gray-600">[${new Date().toLocaleTimeString()}]</span> ${message}`;
            feed.prepend(p);
            
            // Keep only last 20 logs
            while(feed.children.length > 20) {
                feed.lastChild.remove();
            }
        }
        
        function initChart() {
            const ctx = document.getElementById('lossChart').getContext('2d');
            lossChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Local Loss',
                        data: [],
                        borderColor: '#00FF00',
                        backgroundColor: 'rgba(0, 255, 0, 0.1)',
                        tension: 0.4,
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: { 
                            beginAtZero: false,
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            ticks: { color: '#00FF00' }
                        },
                        x: { 
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            ticks: { color: '#00FF00' }
                        }
                    },
                    plugins: {
                        legend: { labels: { color: '#00FF00' } }
                    }
                }
            });
        }
        
        function updateChart() {
            if (!lossChart) return;
            
            lossChart.data.labels = lossHistory.map((_, i) => i);
            lossChart.data.datasets[0].data = lossHistory;
            lossChart.update('none');
        }
        
        // Update Data Sources UI
        function updateDataSourcesUI() {
            const sourcesDiv = document.getElementById('data-sources');
            if (!sourcesDiv) return;
            
            let html = '';
            
            // Sort by performance score
            const sortedSources = Object.entries(dataSourceStats)
                .sort((a, b) => {
                    const scoreA = a[1].successRate / (a[1].lastLoss + 0.1);
                    const scoreB = b[1].successRate / (b[1].lastLoss + 0.1);
                    return scoreB - scoreA;
                });
            
            for (const [key, source] of sortedSources) {
                const isActive = key === currentDataSource;
                const performanceScore = ((source.successRate / (source.lastLoss + 0.1)) * 100).toFixed(0);
                
                html += `
                    <div class="flex items-center justify-between p-2 bg-gray-900 bg-opacity-50 rounded ${isActive ? 'border border-yellow-400' : ''}">
                        <div class="flex items-center space-x-2">
                            <span class="text-lg">${source.icon}</span>
                            <span class="${isActive ? 'text-yellow-400 font-bold' : 'text-gray-300'}">${source.name}</span>
                            ${isActive ? '<span class="text-green-400 text-xs">‚óè ACTIVE</span>' : ''}
                        </div>
                        <div class="flex items-center space-x-3">
                            <span class="text-gray-400 text-xs">Loss: ${source.lastLoss.toFixed(2)}</span>
                            <span class="text-gray-400 text-xs">Success: ${(source.successRate * 100).toFixed(0)}%</span>
                            <span class="text-blue-400 text-xs font-bold">Score: ${performanceScore}</span>
                        </div>
                    </div>
                `;
            }
            
            sourcesDiv.innerHTML = html;
        }
        
        // ============================================
        // AI INFERENCE
        // ============================================
        
        async function generateText(seed, length = 50) {
            if (!model) throw new Error("Model not ready");
            
            seed = seed.toLowerCase().replace(/[^a-z .]/g, '');
            if (seed.length < 5) seed = "genesis ai";
            
            let inputIndices = seed.split('').map(c => charToIndex[c] || 0);
            let generated = "";
            
            for (let i = 0; i < length; i++) {
                const char = tf.tidy(() => {
                    const seq = inputIndices.slice(-SEQUENCE_LENGTH);
                    while (seq.length < SEQUENCE_LENGTH) seq.unshift(0);
                    
                    const inputTensor = tf.tensor2d([seq]);
                    const prediction = model.predict(inputTensor);
                    const logits = prediction.dataSync();
                    
                    const maxIdx = logits.indexOf(Math.max(...logits));
                    return indexToChar[maxIdx];
                });
                
                generated += char;
                inputIndices.push(charToIndex[char] || 0);
            }
            
            return generated;
        }
        
        // ============================================
        // EVENT LISTENERS
        // ============================================
        
        document.getElementById('mine-btn').addEventListener('click', async () => {
            const btn = document.getElementById('mine-btn');
            const status = document.getElementById('status-text');
            
            if (!isMining) {
                // Start mining
                if (!model) {
                    // üß¨ Determine generation based on NETWORK blockchain height
                    // First, try to sync with network to get latest height
                    if (Object.keys(connections).length > 0) {
                        addLog(`üîÑ Syncing blockchain with ${Object.keys(connections).length} peer(s)...`, "info");
                        
                        const myHeight = blockchain.getBlockchainHeight();
                        console.log(`üìä My blockchain height: ${myHeight}`);
                        
                        // Request chain from all peers (multiple times for reliability)
                        for (let attempt = 0; attempt < 3; attempt++) {
                            Object.values(connections).forEach(conn => {
                                sendToPeer(conn, { type: 'request_chain' });
                            });
                            
                            // Wait 1 second between attempts
                            await new Promise(resolve => setTimeout(resolve, 1000));
                        }
                        
                        const finalHeight = blockchain.getBlockchainHeight();
                        console.log(`üìä Final blockchain height: ${finalHeight}`);
                        
                        if (finalHeight > myHeight) {
                            addLog(`‚úÖ Blockchain synced: ${myHeight} ‚Üí ${finalHeight} blocks`, "success");
                        } else {
                            addLog(`‚ÑπÔ∏è Blockchain already up to date (${finalHeight} blocks)`, "info");
                        }
                    } else {
                        addLog(`‚ö†Ô∏è No peers connected - starting with local blockchain`, "warn");
                    }
                    
                    const blockHeight = blockchain.getBlockchainHeight();
                    currentGeneration = getGenerationFromBlockHeight(blockHeight);
                    
                    console.log(`üß¨ Starting with Generation ${currentGeneration} (Blockchain Height: ${blockHeight})`);
                    
                    model = await createModel(currentGeneration);
                    
                    // Update UI
                    const genText = ['1st', '2nd', '3rd'];
                    const suffix = currentGeneration <= 3 ? genText[currentGeneration - 1] : `${currentGeneration}th`;
                    const units = calculateUnitsForGeneration(currentGeneration);
                    document.getElementById('brain-generation').innerText = `${suffix} Gen`;
                    document.getElementById('brain-generation').title = `${units} units - Generation ${currentGeneration} AI`;
                    
                    // Load saved weights if available
                    const saved = loadWeightsFromStorage();
                    if (saved) {
                        try {
                            const tensors = saved.weights.map(w => tf.tensor(w.data, w.shape));
                            
                            // Verify weight count matches model expectations
                            const modelWeights = model.getWeights();
                            if (tensors.length !== modelWeights.length) {
                                throw new Error(`Weight count mismatch: saved=${tensors.length}, model=${modelWeights.length}`);
                            }
                            
                            model.setWeights(tensors);
                            tensors.forEach(t => t.dispose());
                            localBestLoss = saved.loss;
                            document.getElementById('local-loss').innerText = localBestLoss.toFixed(4);
                            addLog(`üìÇ Loaded saved weights (Loss: ${localBestLoss.toFixed(4)})`, "success");
                        } catch(e) {
                            console.error("‚ùå Failed to load saved weights:", e.message);
                            console.warn("   Clearing incompatible weights...");
                            localStorage.removeItem('p2p_best_weights');
                            addLog("‚ö†Ô∏è Saved weights incompatible with current model (cleared)", "warn");
                        }
                    }
                }
                
                isMining = true;
                btn.innerText = "STOP LEARNING";
                btn.classList.add('bg-green-500', 'text-black');
                status.innerHTML = 'Status: <span class="text-green-500">MINING ‚ö°</span>';
                
                addLog("‚ö° Started distributed learning", "success");
                trainStep();
            } else {
                // Stop mining
                isMining = false;
                btn.innerText = "START DISTRIBUTED LEARNING";
                btn.classList.remove('bg-green-500', 'text-black');
                status.innerHTML = 'Status: <span class="text-red-500">OFFLINE</span>';
                
                addLog("‚è∏Ô∏è Stopped learning", "warn");
            }
        });
        
        document.getElementById('share-btn').addEventListener('click', async () => {
            const shareURL = generateShareURL();
            
            try {
                await navigator.clipboard.writeText(shareURL);
                addLog("üìã Invite link copied to clipboard!", "success");
                
                const btn = document.getElementById('share-btn');
                const originalText = btn.innerText;
                btn.innerText = "‚úÖ COPIED!";
                setTimeout(() => {
                    btn.innerText = originalText;
                }, 2000);
            } catch(e) {
                // Fallback: show URL in prompt
                prompt("Copy this URL to invite peers:", shareURL);
            }
        });
        
        // Copy Peer ID button
        document.getElementById('copy-peer-id').addEventListener('click', async () => {
            if (!myPeerId) return;
            
            try {
                await navigator.clipboard.writeText(myPeerId);
                addLog(`üìã Peer ID copied: ${myPeerId}`, "success");
                
                const btn = document.getElementById('my-peer-id');
                const originalText = btn.innerText;
                btn.innerText = "‚úÖ Copied!";
                setTimeout(() => {
                    btn.innerText = originalText;
                }, 2000);
            } catch(e) {
                prompt("Copy this Peer ID:", myPeerId);
            }
        });
        
        // Manual connect button
        // Calculate localStorage usage
        function updateStorageUsage() {
            try {
                let totalSize = 0;
                for (let key in localStorage) {
                    if (localStorage.hasOwnProperty(key)) {
                        totalSize += localStorage[key].length + key.length;
                    }
                }
                
                const sizeKB = (totalSize / 1024).toFixed(2);
                const sizeMB = (totalSize / 1024 / 1024).toFixed(2);
                
                const displaySize = totalSize > 1024 * 1024 ? `${sizeMB} MB` : `${sizeKB} KB`;
                document.getElementById('storage-used').innerText = displaySize;
                
                // Warn if approaching limit (> 4MB)
                if (totalSize > 4 * 1024 * 1024) {
                    document.getElementById('storage-used').classList.add('text-red-400');
                    document.getElementById('storage-used').classList.remove('text-yellow-400');
                } else {
                    document.getElementById('storage-used').classList.add('text-yellow-400');
                    document.getElementById('storage-used').classList.remove('text-red-400');
                }
            } catch(e) {
                console.error("Failed to calculate storage:", e);
            }
        }
        
        // Cleanup button
        document.getElementById('cleanup-btn').addEventListener('click', () => {
            if (!confirm('Clear cache? This will:\n‚Ä¢ Remove blockchain (will re-sync from network)\n‚Ä¢ Keep your wallet and balance\n‚Ä¢ Keep best weights')) {
                return;
            }
            
            console.log("üßπ Manual cleanup requested");
            cleanupLocalStorage();
            updateStorageUsage();
            addLog("‚úÖ Cache cleared! Blockchain will re-sync from network.", "success");
        });
        
        // Manual connect button
        document.getElementById('manual-connect-btn').addEventListener('click', () => {
            const peerIdInput = document.getElementById('manual-peer-id');
            const peerId = peerIdInput.value.trim();
            
            if (!peerId) {
                addLog("‚ö†Ô∏è Please enter a Peer ID", "warn");
                return;
            }
            
            if (peerId === myPeerId) {
                addLog("‚ö†Ô∏è Cannot connect to yourself!", "warn");
                return;
            }
            
            if (connections[peerId]) {
                addLog(`‚ÑπÔ∏è Already connected to ${peerId.substring(0, 8)}`, "info");
                return;
            }
            
            addLog(`üîó Manually connecting to ${peerId.substring(0, 8)}...`, "info");
            connectToPeer(peerId);
            peerIdInput.value = '';
        });
        
        // Update storage usage periodically
        setInterval(() => {
            updateStorageUsage();
        }, 10000); // Every 10 seconds
        
        document.getElementById('inference-btn').addEventListener('click', async () => {
            const input = document.getElementById('inference-input');
            const output = document.getElementById('inference-output');
            const seed = input.value.trim();
            
            if (!seed) return;
            
            try {
                output.classList.remove('hidden');
                output.innerHTML = '<span class="animate-pulse">Generating...</span>';
                
                const text = await generateText(seed, 80);
                output.innerHTML = `<span class="text-gray-400">Seed:</span> "${seed}"<br><span class="text-green-400">Generated:</span> ${text}`;
                
                addLog(`ü§ñ Generated text from seed: "${seed.substring(0, 20)}..."`, "info");
            } catch(e) {
                output.innerHTML = `<span class="text-red-400">Error: ${e.message}</span>`;
            }
        });
        
        // ============================================
        // INITIALIZATION
        // ============================================
        
        loadBalance();             // 1. Load balance first
        loadCollaborationStats();  // 2. Load collaboration statistics
        initGlobalLedger();        // 3. Initialize global ledger
        initChart();               // 4. Initialize chart
        updateDataSourcesUI();     // 5. Initialize data sources display
        updateStorageUsage();      // 6. Check storage usage
        initIPFS();                // 7. Initialize IPFS (Decentralized storage)
        initP2P();                 // 7. Initialize P2P network
        
        // Periodic gossip
        setInterval(() => {
            if (Object.keys(connections).length > 0) {
                broadcastToNetwork({
                    type: 'hello',
                    loss: localBestLoss,
                    wallet: walletAddress,
                    myPeerId: myPeerId
                });
            }
        }, GOSSIP_INTERVAL);
        
        // Periodic data source UI update
        setInterval(() => {
            updateDataSourcesUI();
            
            // Update network generation display
            const blockHeight = blockchain.getBlockchainHeight();
            const networkGeneration = getGenerationFromBlockHeight(blockHeight);
            const genText = ['1st', '2nd', '3rd'];
            const netGenText = networkGeneration <= 3 ? genText[networkGeneration - 1] : `${networkGeneration}th`;
            
            const networkGenEl = document.getElementById('network-gen-value');
            if (networkGenEl) {
                networkGenEl.innerText = `${netGenText} Gen`;
            }
            
            // Show blockchain height next to generation
            document.getElementById('blocks-received').innerText = blockHeight;
            
            // Show sync warning if mining and generations don't match
            const syncWarning = document.getElementById('sync-warning');
            if (syncWarning && isMining && currentGeneration !== networkGeneration) {
                syncWarning.classList.remove('hidden');
            } else if (syncWarning) {
                syncWarning.classList.add('hidden');
            }
            
            // Update explorer if it's the active tab
            if (currentTab === 'explorer') {
                updateExplorerView();
            }
            
            // Update chat tab if it's active
            if (currentTab === 'chat') {
                document.getElementById('chat-peers').innerText = Object.keys(connections).length;
                document.getElementById('chat-balance').innerText = balance.toFixed(2);
            }
        }, 5000); // Update every 5 seconds
        
        addLog("üöÄ Pure P2P Genesis AI initialized", "success");
        addLog("‚ö° Zero servers - No Firebase - Fully decentralized!", "info");
        addLog("üí° Click 'COPY INVITE LINK' to share with friends", "info");
        
    </script>
</body>
</html>






