<!DOCTYPE html>
<!--
üöÄ PURE P2P GENESIS AI - 100% Decentralized Neural Network

HOW IT WORKS:
1. No Firebase! No central server!
2. Peer discovery via:
   - URL sharing (?peer=xxx)
   - localStorage (remembers past peers)
   - Gossip protocol (peers share peer lists)

USAGE:
1. Open this page ‚Üí Get your Peer ID
2. Click "COPY INVITE LINK" 
3. Share link with friends
4. Auto-connect and sync AI models!

NETWORK GROWTH:
- You connect to peer A
- Peer A shares peers B, C, D
- You connect to B, C, D
- Network expands organically!
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pure P2P Genesis AI - Decentralized Neural Network</title>
    
    <!-- CDNs -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/elliptic/6.5.4/elliptic.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

    <!-- No Firebase needed! Pure P2P using localStorage + URL sharing -->

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;600&display=swap');
        
        body {
            font-family: 'Fira Code', monospace;
            background: linear-gradient(135deg, #0A0A0A 0%, #1a0a2e 100%);
            color: #E5E5E5;
        }
        
        .neon-text {
            color: #00FF00;
            text-shadow: 0 0 10px #00FF00, 0 0 20px #00FF00;
        }
        
        .neon-border {
            border: 2px solid #00FF00;
            box-shadow: 0 0 10px #00FF00, inset 0 0 10px rgba(0,255,0,0.1);
        }
        
        .peer-node {
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .terminal-scroll {
            scrollbar-width: thin;
            scrollbar-color: #00FF00 #0A0A0A;
        }
        
        .terminal-scroll::-webkit-scrollbar {
            width: 6px;
        }
        .terminal-scroll::-webkit-scrollbar-track {
            background: #0A0A0A;
        }
        .terminal-scroll::-webkit-scrollbar-thumb {
            background-color: #00FF00;
            border-radius: 3px;
        }
    </style>
</head>
<body class="p-4 min-h-screen">

    <!-- Header -->
    <header class="flex justify-between items-center mb-6 p-4 neon-border bg-black bg-opacity-50">
        <div>
            <h1 class="text-3xl font-bold neon-text">‚ö° PURE P2P GENESIS AI</h1>
            <p class="text-xs text-gray-400">Zero-Server Distributed Neural Network</p>
        </div>
        <div class="text-right">
            <p class="text-xs text-gray-400">WALLET</p>
            <p id="wallet-address" class="text-sm font-bold text-white">Generating...</p>
            <p class="text-xs text-gray-500 mt-1">Balance: <span id="balance" class="text-green-400">0</span> GEN</p>
        </div>
    </header>

    <!-- Main Grid -->
    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
        
        <!-- Left: P2P Network Status -->
        <div class="md:col-span-1 space-y-4">
            
            <!-- Connection Status -->
            <div class="neon-border p-4 bg-black bg-opacity-50">
                <h2 class="text-lg neon-text mb-3">üåê P2P NETWORK</h2>
                
                <!-- Share Button -->
                <button id="share-btn" class="w-full mb-3 py-2 bg-blue-900 hover:bg-blue-700 text-white text-sm font-bold border border-blue-500 transition-colors" disabled>
                    üìã COPY INVITE LINK
                </button>
                
                <div class="space-y-2 text-sm">
                    <div class="flex justify-between">
                        <span class="text-gray-400">My Peer ID</span>
                        <span id="my-peer-id" class="font-mono text-xs">-</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">Connected Peers</span>
                        <span id="connected-peers" class="font-bold text-green-400">0</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">Network Nodes</span>
                        <span id="total-nodes" class="font-bold">0</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">Global Best Loss</span>
                        <span id="global-loss" class="font-bold text-yellow-400">-</span>
                    </div>
            </div>
            
                <div class="mt-4 pt-4 border-t border-gray-700">
                    <p class="text-xs text-gray-400 mb-2">Connected Peers:</p>
                    <div id="peer-list" class="space-y-1 max-h-32 overflow-y-auto terminal-scroll">
                        <p class="text-xs text-gray-500">No peers connected</p>
                </div>
            </div>
        </div>

            <!-- Mining Control -->
            <div class="neon-border p-4 bg-black bg-opacity-50 text-center">
                <h2 class="text-xl font-bold mb-4">‚öôÔ∏è MINING CONTROL</h2>
                <button id="mine-btn" class="w-full py-4 bg-transparent border-2 border-green-500 text-green-500 font-bold text-xl hover:bg-green-500 hover:text-black transition-all duration-200 shadow-[0_0_15px_#00FF00]">
                    START DISTRIBUTED LEARNING
                </button>
                <p id="status-text" class="mt-3 text-sm">
                    Status: <span class="text-red-500">OFFLINE</span>
                </p>
            </div>

            <!-- Stats -->
            <div class="neon-border p-4 bg-black bg-opacity-50">
                <h2 class="text-lg neon-text mb-3">üìä LOCAL STATS</h2>
                <div class="space-y-2 text-sm">
                    <div class="flex justify-between">
                        <span class="text-gray-400">Local Epochs</span>
                        <span id="epochs" class="font-bold">0</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">Best Local Loss</span>
                        <span id="local-loss" class="font-bold text-blue-400">-</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">Model Params</span>
                        <span id="model-params" class="font-bold">-</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">‚õìÔ∏è Blockchain Height</span>
                        <span id="blocks-received" class="font-bold text-purple-400">0</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">üåç Network Miners</span>
                        <span id="network-miners" class="font-bold text-cyan-400">0</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">üíé Total GEN Mined</span>
                        <span id="total-mined" class="font-bold text-yellow-400">0</span>
                    </div>
                    <div class="flex justify-between border-t border-gray-700 pt-2 mt-2">
                        <span class="text-gray-400">üß¨ Brain Generation</span>
                        <span id="brain-generation" class="font-bold text-green-400">1st Gen</span>
                    </div>
                    <div class="flex justify-between">
                        <span class="text-gray-400">üìà Next Evolution</span>
                        <span id="evolution-progress" class="font-bold text-gray-400">0/10 blocks</span>
                    </div>
                    </div>
                </div>
            </div>

        <!-- Middle: Training Visualization -->
        <div class="md:col-span-2 space-y-4">
            
            <!-- Loss Chart -->
            <div class="neon-border p-4 bg-black bg-opacity-50 h-80">
                <h2 class="text-lg neon-text mb-2">üß† NEURAL EVOLUTION (LOSS)</h2>
                <canvas id="lossChart"></canvas>
                    </div>
            
            <!-- Current Learning Data -->
            <div class="neon-border p-4 bg-black bg-opacity-50">
                <h2 class="text-lg neon-text mb-2">üìñ CURRENTLY LEARNING</h2>
                <div id="learning-preview" class="text-xs p-3 bg-gray-900 bg-opacity-50 text-gray-300 italic rounded h-24 overflow-y-auto terminal-scroll">
                    <span class="text-gray-500">No data yet...</span>
                    </div>
                    </div>
            
            <!-- P2P Activity Feed -->
            <div class="neon-border p-4 bg-black bg-opacity-50 flex flex-col">
                <h2 class="text-lg neon-text mb-2">üì° P2P ACTIVITY LOG</h2>
                <div id="activity-feed" class="terminal-scroll flex-grow overflow-y-auto h-48 text-xs space-y-1 p-2 bg-gray-900 bg-opacity-30 font-mono">
                    <p class="text-gray-500">> System initialized in Pure P2P mode</p>
                    <p class="text-gray-500">> No central server - all data P2P synchronized</p>
                    </div>
                </div>
            
            <!-- AI Inference Test -->
            <div class="neon-border p-4 bg-black bg-opacity-50">
                <h2 class="text-lg neon-text mb-2">ü§ñ TEST LOCAL AI</h2>
                <div class="flex gap-2">
                    <input type="text" id="inference-input" placeholder="Type seed text..." class="flex-grow bg-black border border-green-900 text-green-400 p-2 text-sm">
                    <button id="inference-btn" class="px-4 py-2 bg-green-900 hover:bg-green-700 text-white font-bold">GENERATE</button>
            </div>
                <div id="inference-output" class="mt-2 p-2 bg-gray-900 text-green-300 text-sm min-h-12 hidden"></div>
        </div>
        </div>
    </div>

    <script>
        // ============================================
        // PURE P2P GENESIS AI - ZERO SERVER ARCHITECTURE
        // ============================================
        
        console.log("üöÄ Initializing Pure P2P Genesis AI...");
        
        // --- Configuration ---
        const SEQUENCE_LENGTH = 10;
        const VOCAB = 'abcdefghijklmnopqrstuvwxyz .';
        const vocab = VOCAB.split('');
        const charToIndex = {};
        const indexToChar = {};
        vocab.forEach((c, i) => {
            charToIndex[c] = i;
            indexToChar[i] = c;
        });
        
        const MAX_PEERS = 5; // Connect to maximum 5 peers
        const GOSSIP_INTERVAL = 5000; // Broadcast state every 5 seconds
        const TRAINING_DATA_LENGTH = 200; // Length of training text
        
        // --- üéØ Í∞úÏ°∞Îêú ÏÇºÏ§ë Î≥¥ÏÉÅ ÏãúÏä§ÌÖú ---
        const REWARD_PER_EPOCH = 0.01;      // Í≥µÎ∂Ä 1Î≤àÎãπ ÏÜåÏï° Î≥¥ÏÉÅ (PoW - Ïó∞ÏÇ∞Î†• Í∏∞Ïó¨)
        const BLOCK_WIN_REWARD = 5.0;       // Î∏îÎ°ù ÏÉùÏÑ± ÏÑ±Í≥µ Ïãú Î≥¥ÎÑàÏä§ (PoW - ÏÑ±Í≥º Î≥¥ÏÉÅ)
        const VALIDATION_REWARD = 0.1;      // Î∏îÎ°ù Í≤ÄÏ¶ù ÏÑ±Í≥µ Ïãú Î≥¥ÏÉÅ (PoV - Í≤ÄÏ¶ùÏûê Î≥¥ÏÉÅ)
        const VALIDATION_THRESHOLD = 0.05;  // Í≤ÄÏ¶ù Ïò§Ï∞® ÌóàÏö© Î≤îÏúÑ (ÏàòÏπò Ï°∞Ïûë Î∞©ÏßÄ)
        
        // --- Wallet & Security ---
        const EC = elliptic.ec;
        const ec = new EC('secp256k1');
        
        let keyPair, privateKey, publicKey, walletAddress;
        
        function initWallet() {
            const saved = localStorage.getItem('p2p_genesis_wallet');
            if (saved) {
                privateKey = saved;
                keyPair = ec.keyFromPrivate(privateKey);
                console.log("üîê Wallet restored from localStorage");
            } else {
                keyPair = ec.genKeyPair();
                privateKey = keyPair.getPrivate('hex');
                localStorage.setItem('p2p_genesis_wallet', privateKey);
                console.log("üÜï New wallet generated");
            }
            publicKey = keyPair.getPublic('hex');
            walletAddress = "P2P_" + publicKey.substring(0, 12).toUpperCase();
            document.getElementById('wallet-address').innerText = walletAddress;
        }
        
        initWallet();
        
        // --- Balance Management ---
        let balance = 0;
        
        function loadBalance() {
            const saved = localStorage.getItem('p2p_balance');
            if (saved) {
                balance = parseFloat(saved);
            } else {
                balance = 0;
            }
            updateBalanceUI();
        }
        
        function addBalance(amount) {
            balance += amount;
            localStorage.setItem('p2p_balance', balance.toString());
            updateBalanceUI();
            console.log(`üí∞ Balance updated: +${amount} GEN (Total: ${balance})`);
        }
        
        function updateBalanceUI() {
            document.getElementById('balance').innerText = balance.toFixed(2);
            
            // Update Global Ledger Stats (ÏïàÏ†ÑÌïòÍ≤å Ï≤òÎ¶¨)
            if (typeof globalLedger !== 'undefined' && globalLedger) {
                const minerCount = Object.keys(globalLedger).length;
                const totalMined = Object.values(globalLedger).reduce((a, b) => a + b, 0);
                
                document.getElementById('network-miners').innerText = minerCount;
                document.getElementById('total-mined').innerText = totalMined.toFixed(2);
            } else {
                document.getElementById('network-miners').innerText = '0';
                document.getElementById('total-mined').innerText = '0.00';
            }
        }
        
        // --- P2P Network State ---
        let peer = null;
        let myPeerId = null;
        let connections = {}; // {peerId: connection}
        let networkState = {
            bestLoss: 9.9,
            bestWeights: null,
            blocksReceived: 0
        };
        
        // --- Global Ledger (Î∂ÑÏÇ∞ Ïû•Î∂Ä) ---
        let globalLedger = {}; // {ÏßÄÍ∞ëÏ£ºÏÜå: ÏûîÏï°} - Î™®Îì† Ï∞∏Ïó¨ÏûêÏùò ÏûîÏï° Í∏∞Î°ù
        
        function initGlobalLedger() {
            const saved = localStorage.getItem('p2p_global_ledger');
            if (saved) {
                globalLedger = JSON.parse(saved);
                console.log("üìÇ Global Ledger loaded:", Object.keys(globalLedger).length, "accounts");
            } else {
                globalLedger = {};
                globalLedger[walletAddress] = balance; // ÎÇ¥ Í≥ÑÏ†ï Îì±Î°ù
            }
        }
        
        function saveGlobalLedger() {
            localStorage.setItem('p2p_global_ledger', JSON.stringify(globalLedger));
        }
        
        function updateGlobalLedger(minerAddress, reward) {
            globalLedger[minerAddress] = (globalLedger[minerAddress] || 0) + reward;
            saveGlobalLedger();
        }
        
        // Weights Hash Í≥ÑÏÇ∞ (Î∏îÎ°ùÏ≤¥Ïù∏ Í≤ÄÏ¶ùÏö©)
        function hashWeights(weights) {
            if (!weights || weights.length === 0) return "0000000000000000";
            const sum = weights.map(w => w.data.reduce((a, b) => a + b, 0))
                .reduce((a, b) => a + b, 0);
            return Math.abs(sum).toString(16).substring(0, 16).padStart(16, '0');
        }
        
        // ============================================
        // BLOCKCHAIN IMPLEMENTATION
        // ============================================
        
        class Block {
            constructor(index, timestamp, previousHash, data) {
                this.index = index;
                this.timestamp = timestamp;
                this.previousHash = previousHash;
                this.miner = data.miner;
                this.loss = data.loss;
                this.weightsHash = data.weightsHash;
                this.peerId = data.peerId;
                this.reward = data.reward || 0;
                
                // üîê Í≤ÄÏ¶ùÏö© Îç∞Ïù¥ÌÑ∞ Ìè¨Ìï® (PoV - Proof of Validation)
                this.weights = data.weights || null;         // Ï†ÑÏ≤¥ Í∞ÄÏ§ëÏπò (Í≤ÄÏ¶ù Í∞ÄÎä•)
                this.trainingData = data.trainingData || ""; // ÌïôÏäµ Îç∞Ïù¥ÌÑ∞ Ï¶ùÍ±∞
                
                this.hash = this.calculateHash();
            }
            
            calculateHash() {
                const data = this.index + this.timestamp + this.previousHash + 
                            this.miner + this.loss + this.weightsHash + this.reward;
                // Simple hash (in production, use SHA-256)
                let hash = 0;
                for (let i = 0; i < data.length; i++) {
                    const char = data.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash;
                }
                return Math.abs(hash).toString(16).padStart(16, '0');
            }
        }
        
        class Blockchain {
            constructor() {
                this.chain = this.loadChain() || [this.createGenesisBlock()];
                this.saveChain();
            }
            
            createGenesisBlock() {
                return new Block(0, Date.now(), "0", {
                    miner: "GENESIS",
                    loss: 9.9,
                    weightsHash: "0000000000000000",
                    peerId: "SYSTEM",
                    reward: 0,
                    weights: null,
                    trainingData: "Genesis Block - The Beginning"
                });
            }
            
            getLatestBlock() {
                return this.chain[this.chain.length - 1];
            }
            
            addBlock(data) {
                const previousBlock = this.getLatestBlock();
                const newBlock = new Block(
                    previousBlock.index + 1,
                    Date.now(),
                    previousBlock.hash,
                    data
                );
                
                // Validate before adding
                if (this.isValidNewBlock(newBlock, previousBlock)) {
                    this.chain.push(newBlock);
                    this.saveChain();
                    
                    // Broadcast to network
                    this.broadcastBlock(newBlock);
                    
                    console.log(`‚õìÔ∏è Block #${newBlock.index} added to chain`);
                    return newBlock;
                }
                return null;
            }
            
            isValidNewBlock(newBlock, previousBlock) {
                // Í≤ÄÏ¶ù 1: Î∏îÎ°ù Ïù∏Îç±Ïä§Í∞Ä ÏàúÏ∞®Ï†ÅÏù∏Í∞Ä?
                if (previousBlock.index + 1 !== newBlock.index) {
                    console.warn("‚ùå Invalid index:", newBlock.index, "expected:", previousBlock.index + 1);
                    return false;
                }
                
                // Í≤ÄÏ¶ù 2: Ïù¥Ï†Ñ Î∏îÎ°ùÍ≥º Ïó∞Í≤∞ÎêòÎäîÍ∞Ä?
                if (previousBlock.hash !== newBlock.previousHash) {
                    console.warn("‚ùå Invalid previous hash");
                    return false;
                }
                
                // Í≤ÄÏ¶ù 3: Î∏îÎ°ù Ìï¥ÏãúÍ∞Ä Ï†ïÌôïÌïúÍ∞Ä?
                if (newBlock.calculateHash() !== newBlock.hash) {
                    console.warn("‚ùå Invalid hash");
                    return false;
                }
                
                // Í≤ÄÏ¶ù 4: Ïã§Ï†úÎ°ú ÏßÄÎä•Ïù¥ Ìñ•ÏÉÅÎêòÏóàÎäîÍ∞Ä? (LossÍ∞Ä Îçî ÎÇÆÏùÄÍ∞Ä?)
                if (newBlock.index > 0 && newBlock.loss >= previousBlock.loss) {
                    console.warn("‚ùå Loss not improved:", newBlock.loss, ">=", previousBlock.loss);
                    return false;
                }
                
                return true;
            }
            
            isValidChain(chain) {
                if (JSON.stringify(chain[0]) !== JSON.stringify(this.createGenesisBlock())) {
                    return false;
                }
                
                for (let i = 1; i < chain.length; i++) {
                    const block = Object.assign(new Block(0, 0, "0", {}), chain[i]);
                    const previousBlock = chain[i - 1];
                    
                    if (!this.isValidNewBlock(block, previousBlock)) {
                        return false;
                    }
                }
                return true;
            }
            
            replaceChain(newChain) {
                if (newChain.length > this.chain.length && this.isValidChain(newChain)) {
                    console.log('üîÑ Replacing chain with longer valid chain');
                    this.chain = newChain;
                    this.saveChain();
                    return true;
                }
                return false;
            }
            
            saveChain() {
                try {
                    localStorage.setItem('p2p_blockchain', JSON.stringify(this.chain));
                } catch(e) {
                    console.error("Failed to save blockchain:", e);
                }
            }
            
            loadChain() {
                try {
                    const saved = localStorage.getItem('p2p_blockchain');
                    if (saved) {
                        const chain = JSON.parse(saved);
                        console.log(`üìÇ Loaded blockchain: ${chain.length} blocks`);
                        return chain;
                    }
                } catch(e) {
                    console.error("Failed to load blockchain:", e);
                }
                return null;
            }
            
            broadcastBlock(block) {
                Object.values(connections).forEach(conn => {
                    try {
                        conn.send({
                            type: 'new_block',
                            block: block
                        });
                    } catch(e) {
                        console.error("Failed to broadcast block:", e);
                    }
                });
            }
            
            getBlockchainHeight() {
                return this.chain.length - 1; // Exclude genesis
            }
        }
        
        // Initialize blockchain
        let blockchain = new Blockchain();
        
        // Update UI
        document.getElementById('blocks-received').innerText = blockchain.getBlockchainHeight();
        
        // --- AI Model ---
        let model = null;
        let isMining = false;
        let epochCount = 0;
        let localBestLoss = 9.9;
        let lossHistory = [];
        
        // --- Evolution System ---
        let currentGeneration = 1;
        const EVOLUTION_INTERVAL = 10; // Î∏îÎ°ù 10Í∞úÎßàÎã§ ÏßÑÌôî
        
        function getGenerationFromBlockHeight(blockHeight) {
            return Math.floor(blockHeight / EVOLUTION_INTERVAL) + 1;
        }
        
        function calculateUnitsForGeneration(gen) {
            return 32 + (gen - 1) * 16; // Gen 1: 32, Gen 2: 48, Gen 3: 64, Gen 4: 80...
        }
        
        // --- Chart ---
        let lossChart = null;
        
        // ============================================
        // PEER DISCOVERY (No Firebase!)
        // ============================================
        
        // Method 1: URL parameter (share link to connect)
        // Method 2: localStorage (remember previous peers)
        // Method 3: Bootstrap node (hardcoded seed peer)
        
        let knownPeers = new Set();
        
        // Load previously connected peers from localStorage
        function loadKnownPeers() {
            try {
                const saved = localStorage.getItem('p2p_known_peers');
                if (saved) {
                    const peers = JSON.parse(saved);
                    peers.forEach(p => knownPeers.add(p));
                    console.log(`üìÇ Loaded ${peers.length} known peers from history`);
                }
            } catch(e) {
                console.error("Failed to load known peers:", e);
            }
        }
        
        // Save peer for future connections
        function rememberPeer(peerId) {
            knownPeers.add(peerId);
            try {
                localStorage.setItem('p2p_known_peers', JSON.stringify([...knownPeers]));
            } catch(e) {
                console.error("Failed to save peer:", e);
            }
        }
        
        // Get peer ID from URL parameter (?peer=xxx)
        function getPeerFromURL() {
            const params = new URLSearchParams(window.location.search);
            return params.get('peer');
        }
        
        // Generate shareable URL with your peer ID
        function generateShareURL() {
            if (!myPeerId) return '';
            const baseURL = window.location.origin + window.location.pathname;
            return `${baseURL}?peer=${myPeerId}`;
        }
        
        loadKnownPeers();
        
        // ============================================
        // PEERJS INITIALIZATION
        // ============================================
        
        function initP2P() {
            // Try to load saved Peer ID from localStorage
            let savedPeerId = localStorage.getItem('p2p_peer_id');
            
            // Create peer with saved ID (or let PeerJS generate new one)
            const peerConfig = {
                config: {
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:global.stun.twilio.com:3478' }
                    ]
                }
            };
            
            // If we have a saved ID, use it
            if (savedPeerId) {
                peer = new Peer(savedPeerId, peerConfig);
                console.log("üîÑ Restoring Peer ID:", savedPeerId);
            } else {
                peer = new Peer(peerConfig);
                console.log("üÜï Generating new Peer ID");
            }
            
            peer.on('open', (id) => {
                myPeerId = id;
                
                // Save Peer ID to localStorage for future sessions
                localStorage.setItem('p2p_peer_id', id);
                console.log("üÜî My Peer ID:", id, "(saved to localStorage)");
                
                document.getElementById('my-peer-id').innerText = id.substring(0, 8) + "...";
                addLog(`üÜî Peer ID: ${id.substring(0, 12)}... (ÏòÅÍµ¨ Ï†ÄÏû•Îê®)`, "success");
                
                // Enable share button
                document.getElementById('share-btn').disabled = false;
                
                // Show shareable URL
                const shareURL = generateShareURL();
                addLog(`üìã Share URL: ${shareURL.substring(0, 50)}...`, "info");
                
                // Check URL for peer to connect to
                const urlPeer = getPeerFromURL();
                if (urlPeer && urlPeer !== id) {
                    addLog(`üîó Found peer in URL: ${urlPeer.substring(0, 12)}...`, "info");
                    connectToPeer(urlPeer);
                }
                
                // Reconnect to known peers
                if (knownPeers.size > 0) {
                    addLog(`üîÑ Reconnecting to ${knownPeers.size} known peers...`, "info");
                    knownPeers.forEach(peerId => {
                        if (peerId !== id) {
                            setTimeout(() => connectToPeer(peerId), 1000);
                        }
                    });
                }
                
                // Update total nodes (self + known peers)
                document.getElementById('total-nodes').innerText = knownPeers.size + 1;
            });
            
            peer.on('connection', (conn) => {
                setupConnection(conn);
                addLog(`üì• Incoming connection from ${conn.peer.substring(0, 8)}...`, "info");
            });
            
            peer.on('error', (err) => {
                console.error("PeerJS Error:", err);
                addLog(`‚ùå P2P Error: ${err.type}`, "error");
            });
        }
        
        // ============================================
        // PEER CONNECTION
        // ============================================
        
        function connectToPeer(peerId) {
            if (connections[peerId]) return;
            
            const conn = peer.connect(peerId, { reliable: true });
            setupConnection(conn);
        }
        
        function setupConnection(conn) {
            connections[conn.peer] = conn;
            
            conn.on('open', () => {
                addLog(`‚úÖ Connected to ${conn.peer.substring(0, 8)}...`, "success");
                
                // Remember this peer for future connections
                rememberPeer(conn.peer);
                
                updatePeerList();
                
                // Send my current state
                sendToPeer(conn, {
                    type: 'hello',
                    loss: localBestLoss,
                    wallet: walletAddress,
                    myPeerId: myPeerId
                });
                
                // Request weights if I'm a new node (high loss = untrained)
                if (localBestLoss > 5.0 && model) {
                    addLog(`üì• Requesting trained model from ${conn.peer.substring(0, 8)}...`, "info");
                    sendToPeer(conn, {
                        type: 'request_weights'
                    });
                }
                
                // Request blockchain if peer might have longer chain
                setTimeout(() => {
                    sendToPeer(conn, {
                        type: 'request_chain'
                    });
                }, 1000);
            });
            
            conn.on('data', (data) => {
                handlePeerMessage(conn.peer, data);
            });
            
            conn.on('close', () => {
                delete connections[conn.peer];
                addLog(`‚ùå Disconnected from ${conn.peer.substring(0, 8)}...`, "warn");
                updatePeerList();
            });
        }
        
        function updatePeerList() {
            const connectedCount = Object.keys(connections).length;
            document.getElementById('connected-peers').innerText = connectedCount;
            
            const peerListEl = document.getElementById('peer-list');
            if (connectedCount === 0) {
                peerListEl.innerHTML = '<p class="text-xs text-gray-500">No peers connected</p>';
            } else {
                peerListEl.innerHTML = Object.keys(connections).map(peerId => 
                    `<div class="flex items-center gap-2 text-xs">
                        <div class="w-2 h-2 rounded-full bg-green-500 peer-node"></div>
                        <span class="font-mono">${peerId.substring(0, 12)}...</span>
                    </div>`
                ).join('');
            }
        }
        
        // ============================================
        // GOSSIP PROTOCOL & CONSENSUS
        // ============================================
        
        function broadcastToNetwork(message) {
            Object.values(connections).forEach(conn => {
                try {
                    conn.send(message);
                } catch(e) {
                    console.error("Failed to send to peer:", e);
                }
            });
        }
        
        function sendToPeer(conn, message) {
            try {
                conn.send(message);
            } catch(e) {
                console.error("Failed to send message:", e);
            }
        }
        
        function handlePeerMessage(peerId, data) {
            console.log("üì® Received from", peerId.substring(0, 8), ":", data.type);
            
            switch(data.type) {
                case 'hello':
                    addLog(`üëã ${peerId.substring(0, 8)}... says hello (Loss: ${data.loss?.toFixed(4)})`, "info");
                    
                    // Gossip: Share my known peers with new peer
                    if (data.myPeerId && knownPeers.size > 1) {
                        const peersToShare = [...knownPeers].filter(p => p !== peerId && p !== data.myPeerId).slice(0, 3);
                        if (peersToShare.length > 0) {
                            sendToPeer(connections[peerId], {
                                type: 'peer_list',
                                peers: peersToShare
                            });
                        }
                    }
                    break;
                    
                case 'peer_list':
                    // Discovered new peers through gossip
                    if (data.peers && Array.isArray(data.peers)) {
                        data.peers.forEach(newPeer => {
                            if (newPeer !== myPeerId && !connections[newPeer] && Object.keys(connections).length < MAX_PEERS) {
                                addLog(`üîç Discovered peer through gossip: ${newPeer.substring(0, 8)}...`, "info");
                                setTimeout(() => connectToPeer(newPeer), Math.random() * 2000);
                            }
                        });
                    }
                    break;
                    
                case 'weights_update':
                    handleWeightsUpdate(peerId, data);
                    break;
                    
                case 'block':
                    handleNewBlock(peerId, data);
                    break;
                    
                case 'request_weights':
                    sendMyWeights(peerId);
                    break;
                    
                case 'new_block':
                    handleNewBlock(peerId, data);
                    break;
                    
                case 'request_chain':
                    // Send full blockchain + global ledger to peer
                    sendToPeer(connections[peerId], {
                        type: 'blockchain',
                        chain: blockchain.chain,
                        ledger: globalLedger
                    });
                    break;
                    
                case 'blockchain':
                    // Received full chain from peer
                    if (data.chain && blockchain.replaceChain(data.chain)) {
                        addLog(`üîÑ Updated blockchain from ${peerId.substring(0, 8)}... (${data.chain.length} blocks)`, "success");
                        document.getElementById('blocks-received').innerText = blockchain.getBlockchainHeight();
                        
                        // Global LedgerÎèÑ ÎèôÍ∏∞Ìôî (ÌîºÏñ¥Í∞Ä Î≥¥ÎÇ∏ Ïû•Î∂Ä Ï†ïÎ≥¥)
                        if (data.ledger) {
                            Object.keys(data.ledger).forEach(address => {
                                if (!globalLedger[address] || globalLedger[address] < data.ledger[address]) {
                                    globalLedger[address] = data.ledger[address];
                                }
                            });
                            saveGlobalLedger();
                            addLog(`üìä Global ledger synchronized: ${Object.keys(globalLedger).length} accounts`, "info");
                        }
                    }
                    break;
            }
        }
        
        // ============================================
        // PROOF OF VALIDATION (PoV) - Í≤ÄÏ¶ù ÏãúÏä§ÌÖú
        // ============================================
        
        async function verifyLoss(receivedWeights, trainingData, reportedLoss) {
            try {
                console.log("üßê Verifying block: Reported Loss =", reportedLoss);
                
                // 1. ÏûÑÏãú Í≤ÄÏ¶ù Î™®Îç∏ ÏÉùÏÑ±
                const tempModel = await createModel();
                
                // 2. ÏÉÅÎåÄÎ∞©Ïù¥ Î≥¥ÎÇ∏ Í∞ÄÏ§ëÏπòÎ•º ÏûÑÏãú Î™®Îç∏Ïóê Ï†ÅÏö©
                const tensors = receivedWeights.map(w => tf.tensor(w.data, w.shape));
                tempModel.setWeights(tensors);
                
                // 3. ÎèôÏùºÌïú Îç∞Ïù¥ÌÑ∞Î°ú Loss Ïû¨Í≥ÑÏÇ∞
                const { xs, ys } = processData(trainingData);
                
                if (!xs || !ys) {
                    console.warn("‚ö†Ô∏è Invalid training data for verification");
                    tensors.forEach(t => t.dispose());
                    tempModel.dispose();
                    return false;
                }
                
                const evaluation = tempModel.evaluate(xs, ys);
                const actualLoss = await evaluation.data();
                const calculatedLoss = actualLoss[0];
                
                // 4. Ï†ïÎ¶¨
                evaluation.dispose();
                xs.dispose();
                ys.dispose();
                tensors.forEach(t => t.dispose());
                tempModel.dispose();
                
                // 5. Í≤ÄÏ¶ù: Î≥¥Í≥†Îêú LossÏôÄ Ïã§Ï†ú Í≥ÑÏÇ∞Îêú LossÏùò Ï∞®Ïù¥Í∞Ä ÌóàÏö© Î≤îÏúÑ ÎÇ¥Ïù∏Í∞Ä?
                const diff = Math.abs(calculatedLoss - reportedLoss);
                console.log(`üìä Calculated Loss: ${calculatedLoss.toFixed(4)}, Diff: ${diff.toFixed(4)}`);
                
                if (diff < VALIDATION_THRESHOLD) {
                    console.log("‚úÖ Validation PASSED");
                    return true;
                } else {
                    console.warn(`‚ùå Validation FAILED: Difference ${diff.toFixed(4)} exceeds threshold ${VALIDATION_THRESHOLD}`);
                    return false;
                }
            } catch (e) {
                console.error("‚ùå Verification error:", e);
                return false;
            }
        }
        
        async function handleNewBlock(peerId, data) {
            const block = Object.assign(new Block(0, 0, "0", {}), data.block);
            const latestBlock = blockchain.getLatestBlock();
            
            if (block.index === latestBlock.index + 1) {
                addLog(`üßê Verifying block #${block.index} from ${peerId.substring(0, 8)}...`, "info");
                
                // [Step 1] Í∏∞Î≥∏ Î∏îÎ°ùÏ≤¥Ïù∏ Í≤ÄÏ¶ù (Íµ¨Ï°∞Ï†Å Î¨¥Í≤∞ÏÑ±)
                if (!blockchain.isValidNewBlock(block, latestBlock)) {
                    addLog(`‚ùå Block #${block.index} rejected: Invalid structure`, "error");
                    return;
                }
                
                // [Step 2] PoV Í≤ÄÏ¶ù (ÏàòÌïôÏ†Å Ï†ïÌôïÏÑ±) - ÏÉÅÎåÄÎ∞©Ïù¥ Í±∞ÏßìÎßêÌïòÎäîÏßÄ ÌôïÏù∏
                if (block.weights && block.trainingData) {
                    const isLossValid = await verifyLoss(block.weights, block.trainingData, block.loss);
                    
                    if (!isLossValid) {
                        addLog(`‚ö†Ô∏è Block #${block.index} rejected: Loss verification FAILED (ÏàòÏπò Ï°∞Ïûë ÏùòÏã¨!)`, "error");
                        // TODO: ÏïÖÏùòÏ†Å ÎÖ∏ÎìúÎ•º Î∏îÎûôÎ¶¨Ïä§Ìä∏Ïóê Ï∂îÍ∞Ä
                        return;
                    }
                    
                    addLog(`‚úÖ PoV passed: Loss is mathematically correct`, "success");
                    
                    // üéÅ Í≤ÄÏ¶ùÏûê Î≥¥ÏÉÅ ÏßÄÍ∏â (Í≤ÄÏ¶ù ÎÖ∏ÎèôÏóê ÎåÄÌïú Î≥¥ÏÉÅ)
                    addBalance(VALIDATION_REWARD);
                    updateGlobalLedger(walletAddress, VALIDATION_REWARD);
                    addLog(`üîç Validation reward: +${VALIDATION_REWARD} GEN (Í≤ÄÏ¶ù ÏôÑÎ£å!)`, "success");
                } else {
                    console.warn("‚ö†Ô∏è Block has no verification data (legacy block?)");
                }
                
                // [Step 3] Î™®Îì† Í≤ÄÏ¶ù ÌÜµÍ≥º ‚Üí Î∏îÎ°ùÏ≤¥Ïù∏Ïóê Ï∂îÍ∞Ä
                blockchain.chain.push(block);
                blockchain.saveChain();
                
                // üí∞ Ï±ÑÍµ¥ÏûêÏóêÍ≤å Î≥¥ÏÉÅ Ïù∏Ï†ï (Global Ledger ÏóÖÎç∞Ïù¥Ìä∏)
                if (block.reward && block.miner) {
                    updateGlobalLedger(block.miner, block.reward);
                    addLog(`üí∞ Miner reward ${block.reward} GEN credited to ${block.miner.substring(0, 8)}...`, "success");
                }
                
                // UI ÏóÖÎç∞Ïù¥Ìä∏
                document.getElementById('blocks-received').innerText = blockchain.getBlockchainHeight();
                addLog(`‚õìÔ∏è Block #${block.index} accepted (Loss: ${block.loss.toFixed(4)})`, "success");
                
                // üì° Îã§Î•∏ ÌîºÏñ¥ÏóêÍ≤å Ï†ÑÌåå (Gossip Protocol)
                Object.keys(connections).forEach(pid => {
                    if (pid !== peerId) {
                        sendToPeer(connections[pid], {
                            type: 'new_block',
                            block: block
                        });
                    }
                });
            } else if (block.index > latestBlock.index + 1) {
                // Missing blocks, request full chain
                addLog(`‚ö†Ô∏è Missing blocks detected, requesting full chain...`, "warn");
                sendToPeer(connections[peerId], {
                    type: 'request_chain'
                });
            }
        }
        
        async function handleWeightsUpdate(peerId, data) {
            const receivedLoss = data.loss;
            const receivedWeights = data.weights;
            
            addLog(`üß† Weights received from ${peerId.substring(0, 8)}... (Loss: ${receivedLoss.toFixed(4)})`, "info");
            
            // Consensus: Only accept if better than local
            if (receivedLoss < localBestLoss && receivedWeights) {
                console.log(`‚úÖ Accepting better weights (${receivedLoss.toFixed(4)} < ${localBestLoss.toFixed(4)})`);
                
                try {
                    // Apply weights to model
                    if (model) {
                        const tensors = receivedWeights.map(w => tf.tensor(w.data, w.shape));
                        model.setWeights(tensors);
                        tensors.forEach(t => t.dispose());
                        
                        localBestLoss = receivedLoss;
                        document.getElementById('local-loss').innerText = localBestLoss.toFixed(4);
                        
                        // Save to localStorage
                        saveWeightsToStorage(receivedWeights, receivedLoss);
                        
                        addLog(`‚úÖ Applied better weights from network`, "success");
                        
                        // Gossip to other peers
                        broadcastToNetwork({
                            type: 'weights_update',
                            loss: receivedLoss,
                            weights: receivedWeights,
                            origin: peerId
                        });
                    }
                } catch(e) {
                    console.error("Failed to apply weights:", e);
                }
            } else {
                console.log(`‚ùå Rejecting weights (${receivedLoss.toFixed(4)} >= ${localBestLoss.toFixed(4)})`);
            }
            
            // Update global best
            if (receivedLoss < networkState.bestLoss) {
                networkState.bestLoss = receivedLoss;
                document.getElementById('global-loss').innerText = receivedLoss.toFixed(4);
            }
        }
        
        function sendMyWeights(peerId) {
            if (!model) return;
            
            addLog(`üì§ Sharing my model (Loss: ${localBestLoss.toFixed(4)}) with ${peerId.substring(0, 8)}...`, "info");
            
            const weights = model.getWeights().map(w => ({
                data: Array.from(w.dataSync()),
                shape: w.shape
            }));
            
            const conn = connections[peerId];
            if (conn) {
                sendToPeer(conn, {
                    type: 'weights_update',
                    loss: localBestLoss,
                    weights: weights
                });
            }
        }
        
        // ============================================
        // TENSORFLOW.JS MODEL
        // ============================================
        
        async function createModel(generation = 1) {
            const units = calculateUnitsForGeneration(generation);
            const embeddingDim = Math.min(32 + (generation - 1) * 8, 128); // Ï†êÏßÑÏ†ÅÏúºÎ°ú Ï¶ùÍ∞Ä
            
            const model = tf.sequential();
            
            model.add(tf.layers.embedding({
                inputDim: vocab.length,
                outputDim: embeddingDim,
                inputLength: SEQUENCE_LENGTH
            }));
            
            model.add(tf.layers.lstm({
                units: units,
                returnSequences: false,
                kernelInitializer: 'glorotUniform',
                recurrentInitializer: 'glorotUniform'
            }));
            
            model.add(tf.layers.dense({
                units: vocab.length,
                activation: 'softmax',
                kernelInitializer: 'glorotUniform'
            }));
            
            model.compile({
                optimizer: 'adam',
                loss: 'categoricalCrossentropy'
            });
            
            const params = model.countParams();
            document.getElementById('model-params').innerText = (params / 1000).toFixed(1) + 'K';
            
            console.log(`üß† Generation ${generation} Model created: ${units} units, ${params} parameters`);
            return model;
        }
        
        // üß¨ Knowledge Transfer: Ïù¥Ï†Ñ ÏÑ∏ÎåÄÏùò ÏßÄÏãùÏùÑ ÏÉà ÏÑ∏ÎåÄÎ°ú Ï†ÑÏäπ
        async function upgradeBrain(oldModel, newGeneration) {
            console.log(`üß¨ Evolving to Generation ${newGeneration}...`);
            
            const newModel = await createModel(newGeneration);
            
            if (!oldModel) {
                console.log("üÜï First generation, no knowledge to transfer");
                return newModel;
            }
            
            try {
                const oldWeights = oldModel.getWeights();
                const newWeights = newModel.getWeights();
                
                // Í∞ÄÏ§ëÏπò Ï†ÑÏÜ°: Í≤πÏπòÎäî Î∂ÄÎ∂ÑÎßå Î≥µÏÇ¨ (ÏßÄÏãù Î≥¥Ï°¥)
                for (let i = 0; i < Math.min(oldWeights.length, newWeights.length); i++) {
                    const oldShape = oldWeights[i].shape;
                    const newShape = newWeights[i].shape;
                    
                    // ÌÅ¨Í∏∞Í∞Ä Í∞ôÏúºÎ©¥ Í∑∏ÎåÄÎ°ú Î≥µÏÇ¨
                    if (JSON.stringify(oldShape) === JSON.stringify(newShape)) {
                        newWeights[i].dispose();
                        newWeights[i] = tf.clone(oldWeights[i]);
                        console.log(`  ‚úÖ Layer ${i}: Transferred (${oldShape})`);
                    } 
                    // ÌÅ¨Í∏∞Í∞Ä Îã§Î•¥Î©¥ Î∂ÄÎ∂Ñ Î≥µÏÇ¨ (ÌôïÏû•Îêú Î∂ÄÎ∂ÑÏùÄ ÎûúÎç§ Ï¥àÍ∏∞Ìôî)
                    else if (oldShape.length === newShape.length) {
                        const oldData = await oldWeights[i].data();
                        const newData = await newWeights[i].data();
                        
                        // Í≤πÏπòÎäî ÏòÅÏó≠Îßå Î≥µÏÇ¨
                        const copySize = Math.min(oldData.length, newData.length);
                        for (let j = 0; j < copySize; j++) {
                            newData[j] = oldData[j];
                        }
                        
                        const updatedWeight = tf.tensor(newData, newShape);
                        newWeights[i].dispose();
                        newWeights[i] = updatedWeight;
                        console.log(`  ‚ö° Layer ${i}: Partial transfer (${oldShape} ‚Üí ${newShape})`);
                    } else {
                        console.log(`  ‚è≠Ô∏è  Layer ${i}: Skipped (incompatible shapes)`);
                    }
                }
                
                newModel.setWeights(newWeights);
                console.log("‚úÖ Knowledge transfer complete!");
                
            } catch (e) {
                console.warn("‚ö†Ô∏è Knowledge transfer failed:", e);
            }
            
            return newModel;
        }

        // --- Wikipedia Data Foraging - UNLIMITED KNOWLEDGE! ---
        let cachedWikiText = null;
        let lastFetchTime = 0;
        const FETCH_INTERVAL = 5000; // 5Ï¥àÎßàÎã§ ÏÉàÎ°úÏö¥ Îç∞Ïù¥ÌÑ∞ (Îπ†Î•∏ Îã§ÏñëÏÑ±)
        
        async function fetchWikipediaData() {
            try {
                // üé≤ Method 1: ÏôÑÏ†Ñ ÎûúÎç§ ÌéòÏù¥ÏßÄ (Wikipedia Random API)
                const randomUrl = 'https://en.wikipedia.org/api/rest_v1/page/random/summary';
                
                const response = await fetch(randomUrl);
                if (!response.ok) throw new Error("Wikipedia fetch failed");
                
                const data = await response.json();
                const text = data.extract || data.description || "";
                const title = data.title || "Unknown";
                
                if (text.length > 100) {
                    // Show what we're learning
                    const preview = text.substring(0, 200) + "...";
                    document.getElementById('learning-preview').innerHTML = 
                        `<div class="text-yellow-400 font-bold mb-1">üìö ${title}</div>` +
                        `<div class="text-gray-300">${preview}</div>`;
                    
                    addLog(`üìö Learning: ${title}`, "info");
                    console.log(`üìñ New topic: ${title} (${text.length} chars)`);
                    return text;
                }
            } catch (e) {
                console.warn("Wikipedia fetch error:", e);
            }
            
            // Fallback: Îã§ÏñëÌïú Í∏∞Î≥∏ ÌÖçÏä§Ìä∏Îì§
            const fallbacks = [
                "Artificial intelligence and machine learning are transforming our world through neural networks and distributed computing systems.",
                "The universe contains billions of galaxies, each with billions of stars and potentially countless planets.",
                "Philosophy explores fundamental questions about existence, knowledge, values, reason, mind, and language.",
                "Mathematics is the abstract study of topics such as quantity, structure, space, and change.",
                "Evolution by natural selection is the process by which species adapt to their environment over generations."
            ];
            const fallback = fallbacks[Math.floor(Math.random() * fallbacks.length)];
            document.getElementById('learning-preview').innerHTML = 
                `<div class="text-gray-500">Fallback training data</div>`;
            return fallback;
        }
        
        async function generateTrainingData() {
            const now = Date.now();
            
            // 5Ï¥àÎßàÎã§ ÏÉàÎ°úÏö¥ Wikipedia ÌéòÏù¥ÏßÄ (Îã§ÏñëÏÑ± Í∑πÎåÄÌôî!)
            if (!cachedWikiText || (now - lastFetchTime > FETCH_INTERVAL)) {
                cachedWikiText = await fetchWikipediaData();
                lastFetchTime = now;
            }
            
            return cachedWikiText;
        }
        
        function processData(text) {
            const xs = [];
            const ys = [];
            
            text = text.toLowerCase().replace(/[^a-z .]/g, '');
            
            if (text.length <= SEQUENCE_LENGTH) return { xs: null, ys: null };
            
            for (let i = 0; i < text.length - SEQUENCE_LENGTH; i++) {
                const seq = text.slice(i, i + SEQUENCE_LENGTH);
                const target = text[i + SEQUENCE_LENGTH];
                
                xs.push(seq.split('').map(c => charToIndex[c] || 0));
                
                const y = new Array(vocab.length).fill(0);
                y[charToIndex[target] || 0] = 1;
                ys.push(y);
            }
            
            if (xs.length === 0) return { xs: null, ys: null };
            
            return {
                xs: tf.tensor2d(xs, [xs.length, SEQUENCE_LENGTH]),
                ys: tf.tensor2d(ys, [ys.length, vocab.length])
            };
        }

        async function trainStep() {
            if (!isMining || !model) return;
            
            try {
                const trainingText = await generateTrainingData();
                const { xs, ys } = processData(trainingText);
                
                if (!xs || !ys) {
                    setTimeout(trainStep, 1000);
                    return;
                }
                
            const history = await model.fit(xs, ys, {
                epochs: 1,
                    batchSize: 32,
                    shuffle: true,
                    verbose: 0
            });
            
            const loss = history.history.loss[0];
            
                xs.dispose();
                ys.dispose();
                
                // üìä [ÏãúÏä§ÌÖú 1] Í∏∞Ïó¨ Î≥¥ÏÉÅ: Í≥µÎ∂ÄÌïú ÎßåÌÅº ÏùºÎã® ÏßÄÍ∏â (Ïó∞ÏÇ∞Î†• Î≥¥ÏÉÅ)
                addBalance(REWARD_PER_EPOCH);
                epochCount++;
                document.getElementById('epochs').innerText = epochCount;
                
                // Update chart (keep only last 10 data points)
                lossHistory.push(loss);
                if (lossHistory.length > 10) lossHistory.shift();
                updateChart();
                
                // üèÜ [ÏãúÏä§ÌÖú 2] ÏÑ±Í≥º Î≥¥ÏÉÅ: ÏßÄÎä• Ìñ•ÏÉÅ Ïãú Î∏îÎ°ù ÏÉùÏÑ± Î∞è Î≥¥ÎÑàÏä§
                if (loss < localBestLoss) {
                    localBestLoss = loss;
                    document.getElementById('local-loss').innerText = loss.toFixed(4);
                    
                    addLog(`üéâ New best local loss: ${loss.toFixed(4)}`, "success");
                    
                    // Extract weights for verification
                    const weights = model.getWeights().map(w => ({
                        data: Array.from(w.dataSync()),
                        shape: w.shape
                    }));
                    
                    // Calculate weights hash
                    const weightsHash = hashWeights(weights);
                    
                    // üîê Add block to blockchain with FULL verification data
                    const newBlock = blockchain.addBlock({
                        miner: walletAddress,
                        loss: loss,
                        weightsHash: weightsHash,
                        peerId: myPeerId,
                        weights: weights,              // ‚úÖ Ï†ÑÏ≤¥ Í∞ÄÏ§ëÏπò Ìè¨Ìï® (Í≤ÄÏ¶ùÏö©)
                        trainingData: trainingText,    // ‚úÖ ÌïôÏäµ Îç∞Ïù¥ÌÑ∞ Ï¶ùÍ±∞ Ìè¨Ìï®
                        reward: BLOCK_WIN_REWARD       // üéÅ ÏÑ±Í≥º Î≥¥ÏÉÅ (5.0 GEN)
                    });
                    
                    if (newBlock) {
                        document.getElementById('blocks-received').innerText = blockchain.getBlockchainHeight();
                        
                        // Award BLOCK WIN reward (not epoch reward)
                        addBalance(BLOCK_WIN_REWARD);
                        updateGlobalLedger(walletAddress, BLOCK_WIN_REWARD);
                        
                        addLog(`‚õèÔ∏è Block #${newBlock.index} mined! ÏßÄÎä• Ìñ•ÏÉÅ Î≥¥ÎÑàÏä§ üí∞ +${BLOCK_WIN_REWARD} GEN`, "success");
                    }
                    
                    broadcastToNetwork({
                        type: 'weights_update',
                        loss: loss,
                        weights: weights,
                        origin: myPeerId
                    });
                    
                    // Save to localStorage
                    saveWeightsToStorage(weights, loss);
                    
                    // Update global best
                    if (loss < networkState.bestLoss) {
                        networkState.bestLoss = loss;
                        document.getElementById('global-loss').innerText = loss.toFixed(4);
                    }
                }
                
                // üß¨ Check for Evolution (Îß§ Î∏îÎ°ù ÏÉùÏÑ± ÌõÑ)
                const blockHeight = blockchain.getBlockchainHeight();
                const targetGeneration = getGenerationFromBlockHeight(blockHeight);
                
                if (targetGeneration > currentGeneration) {
                    addLog(`üß¨ EVOLUTION TRIGGERED! Gen ${currentGeneration} ‚Üí Gen ${targetGeneration}`, "success");
                    
                    const oldModel = model;
                    model = await upgradeBrain(oldModel, targetGeneration);
                    
                    if (oldModel) {
                        oldModel.dispose();
                    }
                    
                    currentGeneration = targetGeneration;
                    
                    // Update UI
                    const genText = ['1st', '2nd', '3rd'];
                    const suffix = currentGeneration <= 3 ? genText[currentGeneration - 1] : `${currentGeneration}th`;
                    document.getElementById('brain-generation').innerText = `${suffix} Gen`;
                    
                    addLog(`‚ú® Brain upgraded to ${suffix} Generation!`, "success");
                }
                
                // Update evolution progress UI
                const blocksInGen = blockHeight % EVOLUTION_INTERVAL;
                document.getElementById('evolution-progress').innerText = `${blocksInGen}/${EVOLUTION_INTERVAL} blocks`;
                
                setTimeout(trainStep, 0);
                
            } catch(e) {
                console.error("Training error:", e);
                addLog(`‚ùå Training error: ${e.message}`, "error");
                await new Promise(r => setTimeout(r, 1000));
                if (isMining) setTimeout(trainStep, 0);
            }
        }
        
        // ============================================
        // LOCAL STORAGE PERSISTENCE
        // ============================================
        
        function saveWeightsToStorage(weights, loss) {
            try {
                localStorage.setItem('p2p_best_weights', JSON.stringify({
                    weights: weights,
                    loss: loss,
                    timestamp: Date.now()
                }));
                console.log("üíæ Weights saved to localStorage");
            } catch(e) {
                console.error("Failed to save weights:", e);
            }
        }
        
        function loadWeightsFromStorage() {
            try {
                const saved = localStorage.getItem('p2p_best_weights');
                if (saved) {
                    const data = JSON.parse(saved);
                    console.log("üìÇ Found saved weights (Loss:", data.loss.toFixed(4), ")");
                    return data;
                }
            } catch(e) {
                console.error("Failed to load weights:", e);
            }
            return null;
        }
        
        // ============================================
        // UI & VISUALIZATION
        // ============================================
        
        function addLog(message, type = "info") {
            const feed = document.getElementById('activity-feed');
            const p = document.createElement('p');
            
            const colors = {
                info: 'text-blue-400',
                success: 'text-green-400',
                warn: 'text-yellow-400',
                error: 'text-red-400'
            };
            
            p.className = colors[type] || 'text-gray-400';
            p.innerHTML = `<span class="text-gray-600">[${new Date().toLocaleTimeString()}]</span> ${message}`;
            feed.prepend(p);
            
            // Keep only last 20 logs
            while(feed.children.length > 20) {
                feed.lastChild.remove();
            }
        }
        
        function initChart() {
            const ctx = document.getElementById('lossChart').getContext('2d');
            lossChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Local Loss',
                        data: [],
                        borderColor: '#00FF00',
                        backgroundColor: 'rgba(0, 255, 0, 0.1)',
                        tension: 0.4,
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: { 
                            beginAtZero: false,
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            ticks: { color: '#00FF00' }
                        },
                        x: { 
                            grid: { color: 'rgba(255,255,255,0.1)' },
                            ticks: { color: '#00FF00' }
                        }
                    },
                    plugins: {
                        legend: { labels: { color: '#00FF00' } }
                    }
                }
            });
        }
        
        function updateChart() {
            if (!lossChart) return;
            
            lossChart.data.labels = lossHistory.map((_, i) => i);
            lossChart.data.datasets[0].data = lossHistory;
            lossChart.update('none');
        }
        
        // ============================================
        // AI INFERENCE
        // ============================================
        
        async function generateText(seed, length = 50) {
            if (!model) throw new Error("Model not ready");
            
            seed = seed.toLowerCase().replace(/[^a-z .]/g, '');
            if (seed.length < 5) seed = "genesis ai";
            
            let inputIndices = seed.split('').map(c => charToIndex[c] || 0);
            let generated = "";
            
            for (let i = 0; i < length; i++) {
                const char = tf.tidy(() => {
                    const seq = inputIndices.slice(-SEQUENCE_LENGTH);
                    while (seq.length < SEQUENCE_LENGTH) seq.unshift(0);
                    
                    const inputTensor = tf.tensor2d([seq]);
                    const prediction = model.predict(inputTensor);
                    const logits = prediction.dataSync();
                    
                    const maxIdx = logits.indexOf(Math.max(...logits));
                    return indexToChar[maxIdx];
                });
                
                generated += char;
                inputIndices.push(charToIndex[char] || 0);
            }
            
            return generated;
        }
        
        // ============================================
        // EVENT LISTENERS
        // ============================================
        
        document.getElementById('mine-btn').addEventListener('click', async () => {
            const btn = document.getElementById('mine-btn');
            const status = document.getElementById('status-text');
            
            if (!isMining) {
                // Start mining
                if (!model) {
                    // üß¨ ÌòÑÏû¨ Î∏îÎ°ùÏ≤¥Ïù∏ ÎÜíÏù¥ Í∏∞Î∞òÏúºÎ°ú ÏÑ∏ÎåÄ Í≤∞Ï†ï
                    const blockHeight = blockchain.getBlockchainHeight();
                    currentGeneration = getGenerationFromBlockHeight(blockHeight);
                    
                    model = await createModel(currentGeneration);
                    
                    // Update UI
                    const genText = ['1st', '2nd', '3rd'];
                    const suffix = currentGeneration <= 3 ? genText[currentGeneration - 1] : `${currentGeneration}th`;
                    document.getElementById('brain-generation').innerText = `${suffix} Gen`;
                    
                    // Load saved weights if available
                    const saved = loadWeightsFromStorage();
                    if (saved) {
                        try {
                            const tensors = saved.weights.map(w => tf.tensor(w.data, w.shape));
                            model.setWeights(tensors);
                            tensors.forEach(t => t.dispose());
                            localBestLoss = saved.loss;
                            document.getElementById('local-loss').innerText = localBestLoss.toFixed(4);
                            addLog(`üìÇ Loaded saved weights (Loss: ${localBestLoss.toFixed(4)})`, "success");
                        } catch(e) {
                            console.error("Failed to load saved weights:", e);
                        }
                    }
                }
                
                isMining = true;
                btn.innerText = "STOP LEARNING";
                btn.classList.add('bg-green-500', 'text-black');
                status.innerHTML = 'Status: <span class="text-green-500">MINING ‚ö°</span>';
                
                addLog("‚ö° Started distributed learning", "success");
                trainStep();
            } else {
                // Stop mining
                isMining = false;
                btn.innerText = "START DISTRIBUTED LEARNING";
                btn.classList.remove('bg-green-500', 'text-black');
                status.innerHTML = 'Status: <span class="text-red-500">OFFLINE</span>';
                
                addLog("‚è∏Ô∏è Stopped learning", "warn");
            }
        });
        
        document.getElementById('share-btn').addEventListener('click', async () => {
            const shareURL = generateShareURL();
            
            try {
                await navigator.clipboard.writeText(shareURL);
                addLog("üìã Invite link copied to clipboard!", "success");
                
                const btn = document.getElementById('share-btn');
                const originalText = btn.innerText;
                btn.innerText = "‚úÖ COPIED!";
                setTimeout(() => {
                    btn.innerText = originalText;
                }, 2000);
            } catch(e) {
                // Fallback: show URL in prompt
                prompt("Copy this URL to invite peers:", shareURL);
            }
        });
        
        document.getElementById('inference-btn').addEventListener('click', async () => {
            const input = document.getElementById('inference-input');
            const output = document.getElementById('inference-output');
            const seed = input.value.trim();
            
            if (!seed) return;
            
            try {
                output.classList.remove('hidden');
                output.innerHTML = '<span class="animate-pulse">Generating...</span>';
                
                const text = await generateText(seed, 80);
                output.innerHTML = `<span class="text-gray-400">Seed:</span> "${seed}"<br><span class="text-green-400">Generated:</span> ${text}`;
                
                addLog(`ü§ñ Generated text from seed: "${seed.substring(0, 20)}..."`, "info");
            } catch(e) {
                output.innerHTML = `<span class="text-red-400">Error: ${e.message}</span>`;
            }
        });
        
        // ============================================
        // INITIALIZATION
        // ============================================
        
        loadBalance();        // 1. Load balance first
        initGlobalLedger();   // 2. Initialize global ledger
        initChart();          // 3. Initialize chart
        initP2P();            // 4. Initialize P2P network
        
        // Periodic gossip
        setInterval(() => {
            if (Object.keys(connections).length > 0) {
                broadcastToNetwork({
                    type: 'hello',
                    loss: localBestLoss,
                    wallet: walletAddress,
                    myPeerId: myPeerId
                });
            }
        }, GOSSIP_INTERVAL);
        
        addLog("üöÄ Pure P2P Genesis AI initialized", "success");
        addLog("‚ö° Zero servers - No Firebase - Fully decentralized!", "info");
        addLog("üí° Click 'COPY INVITE LINK' to share with friends", "info");
        
    </script>
</body>
</html>





